
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>keeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/volnix-protocol/volnix-protocol/x/anteil/keeper/keeper.go (30.5%)</option>
				
				<option value="file1">github.com/volnix-protocol/volnix-protocol/x/anteil/keeper/msg_server.go (0.0%)</option>
				
				<option value="file2">github.com/volnix-protocol/volnix-protocol/x/anteil/keeper/query_server.go (0.0%)</option>
				
				<option value="file3">github.com/volnix-protocol/volnix-protocol/x/anteil/types/codec.go (0.0%)</option>
				
				<option value="file4">github.com/volnix-protocol/volnix-protocol/x/anteil/types/keys.go (0.0%)</option>
				
				<option value="file5">github.com/volnix-protocol/volnix-protocol/x/anteil/types/params.go (80.4%)</option>
				
				<option value="file6">github.com/volnix-protocol/volnix-protocol/x/anteil/types/params_proto.go (0.0%)</option>
				
				<option value="file7">github.com/volnix-protocol/volnix-protocol/x/anteil/types/types.go (77.3%)</option>
				
				<option value="file8">github.com/volnix-protocol/volnix-protocol/x/ident/keeper/keeper.go (53.6%)</option>
				
				<option value="file9">github.com/volnix-protocol/volnix-protocol/x/ident/keeper/msg_server.go (72.0%)</option>
				
				<option value="file10">github.com/volnix-protocol/volnix-protocol/x/ident/keeper/query_server.go (0.0%)</option>
				
				<option value="file11">github.com/volnix-protocol/volnix-protocol/x/ident/types/account.go (0.0%)</option>
				
				<option value="file12">github.com/volnix-protocol/volnix-protocol/x/ident/types/codec.go (0.0%)</option>
				
				<option value="file13">github.com/volnix-protocol/volnix-protocol/x/ident/types/keys.go (0.0%)</option>
				
				<option value="file14">github.com/volnix-protocol/volnix-protocol/x/ident/types/params.go (73.9%)</option>
				
				<option value="file15">github.com/volnix-protocol/volnix-protocol/x/ident/types/params_proto.go (0.0%)</option>
				
				<option value="file16">github.com/volnix-protocol/volnix-protocol/x/lizenz/keeper/keeper.go (58.1%)</option>
				
				<option value="file17">github.com/volnix-protocol/volnix-protocol/x/lizenz/keeper/msg_server.go (0.0%)</option>
				
				<option value="file18">github.com/volnix-protocol/volnix-protocol/x/lizenz/keeper/query_server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package keeper

import (
        "fmt"

        storetypes "cosmossdk.io/store/types"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "google.golang.org/protobuf/types/known/timestamppb"

        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
        anteiltypes "github.com/volnix-protocol/volnix-protocol/x/anteil/types"
)

type (
        Keeper struct {
                cdc        codec.BinaryCodec
                storeKey   storetypes.StoreKey
                paramstore paramtypes.Subspace
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey storetypes.StoreKey,
        ps paramtypes.Subspace,
) *Keeper <span class="cov8" title="1">{
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() </span><span class="cov0" title="0">{
                ps = ps.WithKeyTable(anteiltypes.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">return &amp;Keeper{
                cdc:        cdc,
                storeKey:   storeKey,
                paramstore: ps,
        }</span>
}

// GetParams returns the current parameters for the anteil module
func (k Keeper) GetParams(ctx sdk.Context) anteiltypes.Params <span class="cov8" title="1">{
        var params anteiltypes.Params
        k.paramstore.GetParamSet(ctx, &amp;params)
        return params
}</span>

// SetParams sets the parameters for the anteil module
func (k Keeper) SetParams(ctx sdk.Context, params anteiltypes.Params) <span class="cov8" title="1">{
        k.paramstore.SetParamSet(ctx, &amp;params)
}</span>

// Order Management Methods

// SetOrder stores an order in the store
func (k Keeper) SetOrder(ctx sdk.Context, order *anteilv1.Order) error <span class="cov8" title="1">{
        if err := anteiltypes.IsOrderValid(order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        orderKey := anteiltypes.GetOrderKey(order.GetOrderId())

        // Check if order already exists
        if store.Has(orderKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrOrderAlreadyExists
        }</span>

        // Store the order
        <span class="cov8" title="1">orderBz, err := k.cdc.Marshal(order)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal order: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(orderKey, orderBz)
        return nil</span>
}

// CreateOrder creates a new order (alias for SetOrder)
func (k Keeper) CreateOrder(ctx sdk.Context, order *anteilv1.Order) error <span class="cov8" title="1">{
        return k.SetOrder(ctx, order)
}</span>

// GetOrder retrieves an order by ID
func (k Keeper) GetOrder(ctx sdk.Context, orderID string) (*anteilv1.Order, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        orderKey := anteiltypes.GetOrderKey(orderID)

        if !store.Has(orderKey) </span><span class="cov8" title="1">{
                return nil, anteiltypes.ErrOrderNotFound
        }</span>

        <span class="cov8" title="1">orderBz := store.Get(orderKey)
        var order anteilv1.Order
        if err := k.cdc.Unmarshal(orderBz, &amp;order); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal order: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;order, nil</span>
}

// UpdateOrder updates an existing order
func (k Keeper) UpdateOrder(ctx sdk.Context, order *anteilv1.Order) error <span class="cov8" title="1">{
        if err := anteiltypes.IsOrderValid(order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        orderKey := anteiltypes.GetOrderKey(order.GetOrderId())

        // Check if order exists
        if !store.Has(orderKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrOrderNotFound
        }</span>

        // Store the updated order
        <span class="cov8" title="1">orderBz, err := k.cdc.Marshal(order)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal order: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(orderKey, orderBz)
        return nil</span>
}

// CancelOrder cancels an existing order
func (k Keeper) CancelOrder(ctx sdk.Context, orderID string) error <span class="cov8" title="1">{
        order, err := k.GetOrder(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update order status to cancelled
        <span class="cov8" title="1">order.Status = anteilv1.OrderStatus_ORDER_STATUS_CANCELLED
        return k.UpdateOrder(ctx, order)</span>
}

// DeleteOrder removes an order from the store
func (k Keeper) DeleteOrder(ctx sdk.Context, orderID string) error <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        orderKey := anteiltypes.GetOrderKey(orderID)

        if !store.Has(orderKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrOrderNotFound
        }</span>

        <span class="cov0" title="0">store.Delete(orderKey)
        return nil</span>
}

// GetAllOrders retrieves all orders
func (k Keeper) GetAllOrders(ctx sdk.Context) ([]*anteilv1.Order, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        orderStore := anteiltypes.NewOrderStore(store)

        var orders []*anteilv1.Order
        iterator := orderStore.Iterator(nil, nil)
        defer func() </span><span class="cov8" title="1">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov8" title="1">for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                var order anteilv1.Order
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal order: %w", err)
                }</span>
                <span class="cov8" title="1">orders = append(orders, &amp;order)</span>
        }

        <span class="cov8" title="1">return orders, nil</span>
}

// Trade Management Methods

// executeTrade executes a trade between two orders
func (k Keeper) executeTrade(ctx sdk.Context, buyOrderID, sellOrderID string) error <span class="cov0" title="0">{
        buyOrder, err := k.GetOrder(ctx, buyOrderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sellOrder, err := k.GetOrder(ctx, sellOrderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate trade compatibility
        <span class="cov0" title="0">if buyOrder.OrderSide != anteilv1.OrderSide_ORDER_SIDE_BUY </span><span class="cov0" title="0">{
                return anteiltypes.ErrInvalidOrderType
        }</span>
        <span class="cov0" title="0">if sellOrder.OrderSide != anteilv1.OrderSide_ORDER_SIDE_SELL </span><span class="cov0" title="0">{
                return anteiltypes.ErrInvalidOrderType
        }</span>

        // Execute the trade
        <span class="cov0" title="0">trade := &amp;anteilv1.Trade{
                TradeId:     fmt.Sprintf("trade_%d", ctx.BlockHeight()),
                BuyOrderId:  buyOrderID,
                SellOrderId: sellOrderID,
                Price:       buyOrder.Price, // Use buy order price
                AntAmount:   buyOrder.AntAmount,
        }

        // Store the trade
        if err := k.SetTrade(ctx, trade); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update order statuses
        <span class="cov0" title="0">buyOrder.Status = anteilv1.OrderStatus_ORDER_STATUS_FILLED
        sellOrder.Status = anteilv1.OrderStatus_ORDER_STATUS_FILLED

        if err := k.UpdateOrder(ctx, buyOrder); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := k.UpdateOrder(ctx, sellOrder); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExecuteTrade executes a trade between orders (public interface)
func (k Keeper) ExecuteTrade(ctx sdk.Context, buyOrderID, sellOrderID string) error <span class="cov0" title="0">{
        return k.executeTrade(ctx, buyOrderID, sellOrderID)
}</span>

// SetTrade stores a trade in the store
func (k Keeper) SetTrade(ctx sdk.Context, trade *anteilv1.Trade) error <span class="cov0" title="0">{
        if err := anteiltypes.IsTradeValid(trade); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        tradeKey := anteiltypes.GetTradeKey(trade.TradeId)

        // Check if trade already exists
        if store.Has(tradeKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrTradeAlreadyExists
        }</span>

        // Store the trade
        <span class="cov0" title="0">tradeBz, err := k.cdc.Marshal(trade)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal trade: %w", err)
        }</span>

        <span class="cov0" title="0">store.Set(tradeKey, tradeBz)
        return nil</span>
}

// GetTrade retrieves a trade by ID
func (k Keeper) GetTrade(ctx sdk.Context, tradeID string) (*anteilv1.Trade, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        tradeKey := anteiltypes.GetTradeKey(tradeID)

        if !store.Has(tradeKey) </span><span class="cov0" title="0">{
                return nil, anteiltypes.ErrTradeNotFound
        }</span>

        <span class="cov0" title="0">tradeBz := store.Get(tradeKey)
        var trade anteilv1.Trade
        if err := k.cdc.Unmarshal(tradeBz, &amp;trade); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal trade: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;trade, nil</span>
}

// GetAllTrades retrieves all trades
func (k Keeper) GetAllTrades(ctx sdk.Context) ([]*anteilv1.Trade, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        tradeStore := anteiltypes.NewTradeStore(store)

        var trades []*anteilv1.Trade
        iterator := tradeStore.Iterator(nil, nil)
        defer func() </span><span class="cov0" title="0">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov0" title="0">for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var trade anteilv1.Trade
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;trade); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal trade: %w", err)
                }</span>
                <span class="cov0" title="0">trades = append(trades, &amp;trade)</span>
        }

        <span class="cov0" title="0">return trades, nil</span>
}

// Auction Management Methods

// SetAuction stores an auction in the store
func (k Keeper) SetAuction(ctx sdk.Context, auction *anteilv1.Auction) error <span class="cov8" title="1">{
        if err := anteiltypes.IsAuctionValid(auction); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        auctionKey := anteiltypes.GetAuctionKey(auction.AuctionId)

        // Check if auction already exists
        if store.Has(auctionKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrAuctionAlreadyExists
        }</span>

        // Store the auction
        <span class="cov8" title="1">auctionBz, err := k.cdc.Marshal(auction)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal auction: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(auctionKey, auctionBz)
        return nil</span>
}

// CreateAuction creates a new auction (alias for SetAuction)
func (k Keeper) CreateAuction(ctx sdk.Context, auction *anteilv1.Auction) error <span class="cov8" title="1">{
        return k.SetAuction(ctx, auction)
}</span>

// GetAuction retrieves an auction by ID
func (k Keeper) GetAuction(ctx sdk.Context, auctionID string) (*anteilv1.Auction, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        auctionKey := anteiltypes.GetAuctionKey(auctionID)

        if !store.Has(auctionKey) </span><span class="cov8" title="1">{
                return nil, anteiltypes.ErrAuctionNotFound
        }</span>

        <span class="cov8" title="1">auctionBz := store.Get(auctionKey)
        var auction anteilv1.Auction
        if err := k.cdc.Unmarshal(auctionBz, &amp;auction); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal auction: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;auction, nil</span>
}

// UpdateAuction updates an existing auction
func (k Keeper) UpdateAuction(ctx sdk.Context, auction *anteilv1.Auction) error <span class="cov0" title="0">{
        if err := anteiltypes.IsAuctionValid(auction); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        auctionKey := anteiltypes.GetAuctionKey(auction.AuctionId)

        // Check if auction exists
        if !store.Has(auctionKey) </span><span class="cov0" title="0">{
                return anteiltypes.ErrAuctionNotFound
        }</span>

        // Store the updated auction
        <span class="cov0" title="0">auctionBz, err := k.cdc.Marshal(auction)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal auction: %w", err)
        }</span>

        <span class="cov0" title="0">store.Set(auctionKey, auctionBz)
        return nil</span>
}

// GetAllAuctions retrieves all auctions
func (k Keeper) GetAllAuctions(ctx sdk.Context) ([]*anteilv1.Auction, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        auctionStore := anteiltypes.NewAuctionStore(store)

        var auctions []*anteilv1.Auction
        iterator := auctionStore.Iterator(nil, nil)
        defer func() </span><span class="cov8" title="1">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov8" title="1">for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                var auction anteilv1.Auction
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;auction); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal auction: %w", err)
                }</span>
                <span class="cov8" title="1">auctions = append(auctions, &amp;auction)</span>
        }

        <span class="cov8" title="1">return auctions, nil</span>
}

// ProcessAuctions processes active auctions
func (k Keeper) ProcessAuctions(ctx sdk.Context) error <span class="cov0" title="0">{
        auctions, err := k.GetAllAuctions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, auction := range auctions </span><span class="cov0" title="0">{
                if auction.Status == anteilv1.AuctionStatus_AUCTION_STATUS_OPEN </span><span class="cov0" title="0">{
                        // Check if auction has ended
                        if ctx.BlockTime().After(auction.EndTime.AsTime()) </span><span class="cov0" title="0">{
                                auction.Status = anteilv1.AuctionStatus_AUCTION_STATUS_CLOSED
                                if err := k.UpdateAuction(ctx, auction); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// BeginBlocker processes auctions and trades
func (k Keeper) BeginBlocker(ctx sdk.Context) error <span class="cov0" title="0">{
        // Process active auctions
        if err := k.ProcessAuctions(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PlaceBid places a bid on an auction
func (k Keeper) PlaceBid(ctx sdk.Context, auctionID string, bidder string, amount string) error <span class="cov0" title="0">{
        auction, err := k.GetAuction(ctx, auctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if auction is still open
        <span class="cov0" title="0">if auction.Status != anteilv1.AuctionStatus_AUCTION_STATUS_OPEN </span><span class="cov0" title="0">{
                return anteiltypes.ErrAuctionClosed
        }</span>

        // Check if auction has ended
        <span class="cov0" title="0">if ctx.BlockTime().After(auction.EndTime.AsTime()) </span><span class="cov0" title="0">{
                return anteiltypes.ErrAuctionExpired
        }</span>

        // Create bid
        <span class="cov0" title="0">bid := &amp;anteilv1.Bid{
                BidId:   fmt.Sprintf("%s_%s_%d", auctionID, bidder, ctx.BlockHeight()),
                Bidder:  bidder,
                Amount:  amount,
                SubmittedAt: timestamppb.Now(),
        }

        // Store bid
        bidKey := anteiltypes.GetBidKey(auctionID, bid.BidId)
        store := ctx.KVStore(k.storeKey)
        bidBz, err := k.cdc.Marshal(bid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">store.Set(bidKey, bidBz)

        // Update auction with new bid
        if auction.WinningBid == "" || bid.Amount &gt; auction.WinningBid </span><span class="cov0" title="0">{
                auction.WinningBid = bid.BidId
                if err := k.UpdateAuction(ctx, auction); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetBid retrieves a bid by ID
func (k Keeper) GetBid(ctx sdk.Context, auctionID, bidID string) (*anteilv1.Bid, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        bidKey := anteiltypes.GetBidKey(auctionID, bidID)

        if !store.Has(bidKey) </span><span class="cov0" title="0">{
                return nil, anteiltypes.ErrBidNotFound
        }</span>

        <span class="cov0" title="0">bidBz := store.Get(bidKey)
        var bid anteilv1.Bid
        if err := k.cdc.Unmarshal(bidBz, &amp;bid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;bid, nil</span>
}

// SettleAuction settles an auction and distributes rewards
func (k Keeper) SettleAuction(ctx sdk.Context, auctionID string) error <span class="cov0" title="0">{
        auction, err := k.GetAuction(ctx, auctionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if auction is closed
        <span class="cov0" title="0">if auction.Status != anteilv1.AuctionStatus_AUCTION_STATUS_CLOSED </span><span class="cov0" title="0">{
                return anteiltypes.ErrAuctionNotClosed
        }</span>

        // Get winning bid
        <span class="cov0" title="0">if auction.WinningBid == "" </span><span class="cov0" title="0">{
                return anteiltypes.ErrNoWinningBid
        }</span>

        <span class="cov0" title="0">_, err = k.GetBid(ctx, auctionID, auction.WinningBid)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Process settlement logic here
        // For now, just mark as settled
        <span class="cov0" title="0">auction.Status = anteilv1.AuctionStatus_AUCTION_STATUS_SETTLED
        return k.UpdateAuction(ctx, auction)</span>
}

// GetUserPosition retrieves user's position in the market
func (k Keeper) GetUserPosition(ctx sdk.Context, user string) (*anteilv1.UserPosition, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        positionKey := anteiltypes.GetUserPositionKey(user)

        if !store.Has(positionKey) </span><span class="cov0" title="0">{
                return nil, anteiltypes.ErrPositionNotFound
        }</span>

        <span class="cov0" title="0">positionBz := store.Get(positionKey)
        var position anteilv1.UserPosition
        if err := k.cdc.Unmarshal(positionBz, &amp;position); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

// SetUserPosition sets user's position
func (k Keeper) SetUserPosition(ctx sdk.Context, position *anteilv1.UserPosition) error <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        positionKey := anteiltypes.GetUserPositionKey(position.Owner)

        positionBz, err := k.cdc.Marshal(position)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">store.Set(positionKey, positionBz)

        return nil</span>
}

// UpdateUserPosition updates user's position
func (k Keeper) UpdateUserPosition(ctx sdk.Context, user string, antBalance string, orderCount uint32) error <span class="cov0" title="0">{
        position := &amp;anteilv1.UserPosition{
                Owner:       user,
                AntBalance:  antBalance,
                TotalTrades: fmt.Sprintf("%d", orderCount),
                LastActivity: timestamppb.Now(),
        }

        return k.SetUserPosition(ctx, position)
}</span>

// GetOrdersByOwner retrieves all orders for a specific owner
func (k Keeper) GetOrdersByOwner(ctx sdk.Context, owner string) ([]*anteilv1.Order, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        prefix := anteiltypes.GetOrderPrefix()

        var orders []*anteilv1.Order
        iterator := store.Iterator(prefix, append(prefix, 0xFF))
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var order anteilv1.Order
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;order); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if order.Owner == owner </span><span class="cov0" title="0">{
                        orders = append(orders, &amp;order)
                }</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}

// EndBlocker processes end-of-block operations
func (k Keeper) EndBlocker(ctx sdk.Context) error <span class="cov0" title="0">{
        // Process any end-of-block logic here
        // For now, just return nil
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package keeper

import (
        "context"

        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
)

type MsgServer struct {
        k Keeper
        anteilv1.UnimplementedMsgServer
}

func NewMsgServer(k *Keeper) MsgServer <span class="cov0" title="0">{ return MsgServer{k: *k} }</span>

var _ anteilv1.MsgServer = MsgServer{}

func (s MsgServer) PlaceOrder(ctx context.Context, req *anteilv1.MsgPlaceOrder) (*anteilv1.MsgPlaceOrderResponse, error) <span class="cov0" title="0">{
        return &amp;anteilv1.MsgPlaceOrderResponse{OrderId: "stub"}, nil
}</span>

func (s MsgServer) CancelOrder(ctx context.Context, req *anteilv1.MsgCancelOrder) (*anteilv1.MsgCancelOrderResponse, error) <span class="cov0" title="0">{
        return &amp;anteilv1.MsgCancelOrderResponse{Success: true}, nil
}</span>

func (s MsgServer) PlaceBid(ctx context.Context, req *anteilv1.MsgPlaceBid) (*anteilv1.MsgPlaceBidResponse, error) <span class="cov0" title="0">{
        return &amp;anteilv1.MsgPlaceBidResponse{Success: true}, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkquery "github.com/cosmos/cosmos-sdk/types/query"
        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
        "google.golang.org/protobuf/encoding/protojson"
)

type QueryServer struct {
        k Keeper
        anteilv1.UnimplementedQueryServer
}

func NewQueryServer(k *Keeper) QueryServer <span class="cov0" title="0">{ return QueryServer{k: *k} }</span>

var _ anteilv1.QueryServer = QueryServer{}

func (s QueryServer) Params(ctx context.Context, _ *anteilv1.QueryParamsRequest) (*anteilv1.QueryParamsResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        params := s.k.GetParams(sdkCtx).ToProto()
        bz, err := protojson.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;anteilv1.QueryParamsResponse{Json: string(bz)}, nil</span>
}

func (s QueryServer) Orders(ctx context.Context, req *anteilv1.QueryOrdersRequest) (*anteilv1.QueryOrdersResponse, error) <span class="cov0" title="0">{
        _ = sdkquery.PageRequest{}
        return &amp;anteilv1.QueryOrdersResponse{Orders: nil, Pagination: nil}, nil
}</span>

func (s QueryServer) Trades(ctx context.Context, req *anteilv1.QueryTradesRequest) (*anteilv1.QueryTradesResponse, error) <span class="cov0" title="0">{
        _ = sdkquery.PageRequest{}
        return &amp;anteilv1.QueryTradesResponse{Trades: nil, Pagination: nil}, nil
}</span>

func (s QueryServer) Auctions(ctx context.Context, req *anteilv1.QueryAuctionsRequest) (*anteilv1.QueryAuctionsResponse, error) <span class="cov0" title="0">{
        _ = sdkquery.PageRequest{}
        return &amp;anteilv1.QueryAuctionsResponse{Auctions: nil, Pagination: nil}, nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package types

import (
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        txtypes "github.com/cosmos/cosmos-sdk/types/tx"

        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
)

func RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        reg.RegisterImplementations((*sdk.Msg)(nil),
                &amp;anteilv1.MsgPlaceOrder{},
                &amp;anteilv1.MsgCancelOrder{},
                &amp;anteilv1.MsgUpdateOrder{},
                &amp;anteilv1.MsgPlaceBid{},
                &amp;anteilv1.MsgSettleAuction{},
                &amp;anteilv1.MsgRegisterMarketMaker{},
                &amp;anteilv1.MsgProvideLiquidity{},
                &amp;anteilv1.MsgWithdrawLiquidity{},
                &amp;anteilv1.MsgStakeANT{},
                &amp;anteilv1.MsgUnstakeANT{},
                &amp;anteilv1.MsgClaimRewards{},
        )
        reg.RegisterImplementations((*txtypes.MsgResponse)(nil),
                &amp;anteilv1.MsgPlaceOrderResponse{},
                &amp;anteilv1.MsgCancelOrderResponse{},
                &amp;anteilv1.MsgUpdateOrderResponse{},
                &amp;anteilv1.MsgPlaceBidResponse{},
                &amp;anteilv1.MsgSettleAuctionResponse{},
                &amp;anteilv1.MsgRegisterMarketMakerResponse{},
                &amp;anteilv1.MsgProvideLiquidityResponse{},
                &amp;anteilv1.MsgWithdrawLiquidityResponse{},
                &amp;anteilv1.MsgStakeANTResponse{},
                &amp;anteilv1.MsgUnstakeANTResponse{},
                &amp;anteilv1.MsgClaimRewardsResponse{},
        )
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package types

const (
        // ModuleName defines the module name
        ModuleName = "anteil"

        // StoreKey is the KVStore key for the anteil module
        StoreKey = ModuleName

        // RouterKey is the msg router key for the anteil module (kept for compatibility)
        RouterKey = ModuleName

        // QuerierRoute is the querier route for the anteil module
        QuerierRoute = ModuleName
)

var (
        // OrderKeyPrefix defines the prefix for order keys
        OrderKeyPrefix = []byte{0x01}

        // TradeKeyPrefix defines the prefix for trade keys
        TradeKeyPrefix = []byte{0x02}

        // UserPositionKeyPrefix defines the prefix for user position keys
        UserPositionKeyPrefix = []byte{0x03}

        // AuctionKeyPrefix defines the prefix for auction keys
        AuctionKeyPrefix = []byte{0x04}

        // BidKeyPrefix defines the prefix for bid keys
        BidKeyPrefix = []byte{0x05}
)

// GetOrderKey returns the key for an order
func GetOrderKey(orderID string) []byte <span class="cov0" title="0">{
        return append(OrderKeyPrefix, []byte(orderID)...)
}</span>

// GetTradeKey returns the key for a trade
func GetTradeKey(tradeID string) []byte <span class="cov0" title="0">{
        return append(TradeKeyPrefix, []byte(tradeID)...)
}</span>

// GetUserPositionKey returns the key for a user position
func GetUserPositionKey(owner string) []byte <span class="cov0" title="0">{
        return append(UserPositionKeyPrefix, []byte(owner)...)
}</span>

// GetAuctionKey returns the key for an auction
func GetAuctionKey(auctionID string) []byte <span class="cov0" title="0">{
        return append(AuctionKeyPrefix, []byte(auctionID)...)
}</span>

// GetBidKey returns the key for a bid
func GetBidKey(auctionID, bidID string) []byte <span class="cov0" title="0">{
        return append(BidKeyPrefix, []byte(auctionID+"_"+bidID)...)
}</span>

// GetOrderPrefix returns the order prefix
func GetOrderPrefix() []byte <span class="cov0" title="0">{
        return OrderKeyPrefix
}</span>

// GetTradePrefix returns the trade prefix
func GetTradePrefix() []byte <span class="cov0" title="0">{
        return TradeKeyPrefix
}</span>

// GetAuctionPrefix returns the auction prefix
func GetAuctionPrefix() []byte <span class="cov0" title="0">{
        return AuctionKeyPrefix
}</span>

// GetBidPrefix returns the bid prefix
func GetBidPrefix() []byte <span class="cov0" title="0">{
        return BidKeyPrefix
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package types

import (
        "fmt"
        "time"

        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

var (
        // KeyMinAntAmount defines the key for minimum ANT amount
        KeyMinAntAmount = []byte("MinAntAmount")

        // KeyMaxAntAmount defines the key for maximum ANT amount
        KeyMaxAntAmount = []byte("MaxAntAmount")

        // KeyTradingFeeRate defines the key for trading fee rate
        KeyTradingFeeRate = []byte("TradingFeeRate")

        // KeyMinOrderSize defines the key for minimum order size
        KeyMinOrderSize = []byte("MinOrderSize")

        // KeyMaxOrderSize defines the key for maximum order size
        KeyMaxOrderSize = []byte("MaxOrderSize")

        // KeyOrderExpiry defines the key for order expiry duration
        KeyOrderExpiry = []byte("OrderExpiry")

        // KeyRequireIdentityVerification defines the key for identity verification requirement
        KeyRequireIdentityVerification = []byte("RequireIdentityVerification")

        // KeyAntDenom defines the key for ANT denomination
        KeyAntDenom = []byte("AntDenom")

        // KeyMaxOpenOrders defines the key for maximum open orders
        KeyMaxOpenOrders = []byte("MaxOpenOrders")

        // KeyPricePrecision defines the key for price precision
        KeyPricePrecision = []byte("PricePrecision")
        
        // New economic parameter keys
        KeyMarketMakerRewardRate = []byte("MarketMakerRewardRate")
        KeyStakingRewardRate     = []byte("StakingRewardRate")
        KeyLiquidityPoolFee      = []byte("LiquidityPoolFee")
        KeyMaxSlippage           = []byte("MaxSlippage")
        KeyMinLiquidityThreshold = []byte("MinLiquidityThreshold")
)

// ParamKeyTable returns the parameter key table
func ParamKeyTable() paramtypes.KeyTable <span class="cov8" title="1">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// Params defines the parameters for the anteil module
type Params struct {
        MinAntAmount                string        `json:"min_ant_amount"`
        MaxAntAmount                string        `json:"max_ant_amount"`
        TradingFeeRate              string        `json:"trading_fee_rate"`
        MinOrderSize                string        `json:"min_order_size"`
        MaxOrderSize                string        `json:"max_order_size"`
        OrderExpiry                 time.Duration `json:"order_expiry"`
        RequireIdentityVerification bool          `json:"require_identity_verification"`
        AntDenom                    string        `json:"ant_denom"`
        MaxOpenOrders               uint32        `json:"max_open_orders"`
        PricePrecision              string        `json:"price_precision"`
        
        // New economic parameters
        MarketMakerRewardRate string `json:"market_maker_reward_rate"`
        StakingRewardRate     string `json:"staking_reward_rate"`
        LiquidityPoolFee      string `json:"liquidity_pool_fee"`
        MaxSlippage           string `json:"max_slippage"`
        MinLiquidityThreshold uint64 `json:"min_liquidity_threshold"`
}

// ParamSetPairs returns the parameter set pairs
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov8" title="1">{
        return paramtypes.ParamSetPairs{
                paramtypes.NewParamSetPair(KeyMinAntAmount, &amp;p.MinAntAmount, validateString),
                paramtypes.NewParamSetPair(KeyMaxAntAmount, &amp;p.MaxAntAmount, validateString),
                paramtypes.NewParamSetPair(KeyTradingFeeRate, &amp;p.TradingFeeRate, validateString),
                paramtypes.NewParamSetPair(KeyMinOrderSize, &amp;p.MinOrderSize, validateString),
                paramtypes.NewParamSetPair(KeyMaxOrderSize, &amp;p.MaxOrderSize, validateString),
                paramtypes.NewParamSetPair(KeyOrderExpiry, &amp;p.OrderExpiry, validateDuration),
                paramtypes.NewParamSetPair(KeyRequireIdentityVerification, &amp;p.RequireIdentityVerification, validateBool),
                paramtypes.NewParamSetPair(KeyAntDenom, &amp;p.AntDenom, validateString),
                paramtypes.NewParamSetPair(KeyMaxOpenOrders, &amp;p.MaxOpenOrders, validateUint32),
                paramtypes.NewParamSetPair(KeyPricePrecision, &amp;p.PricePrecision, validateString),
                
                // New economic parameter pairs
                paramtypes.NewParamSetPair(KeyMarketMakerRewardRate, &amp;p.MarketMakerRewardRate, validateString),
                paramtypes.NewParamSetPair(KeyStakingRewardRate, &amp;p.StakingRewardRate, validateString),
                paramtypes.NewParamSetPair(KeyLiquidityPoolFee, &amp;p.LiquidityPoolFee, validateString),
                paramtypes.NewParamSetPair(KeyMaxSlippage, &amp;p.MaxSlippage, validateString),
                paramtypes.NewParamSetPair(KeyMinLiquidityThreshold, &amp;p.MinLiquidityThreshold, validateUint64),
        }
}</span>

// DefaultParams returns the default parameters for the anteil module
func DefaultParams() Params <span class="cov8" title="1">{
        return Params{
                MinAntAmount:                "1000000",      // 1 ANT in micro units
                MaxAntAmount:                "1000000000",   // 1000 ANT in micro units
                TradingFeeRate:              "0.001",        // 0.1%
                MinOrderSize:                "100000",       // 0.1 ANT in micro units
                MaxOrderSize:                "100000000",    // 100 ANT in micro units
                OrderExpiry:                 24 * time.Hour, // 24 hours
                RequireIdentityVerification: true,
                AntDenom:                    "uant",
                MaxOpenOrders:               10,
                PricePrecision:              "0.000001", // 6 decimal places
                
                // New economic parameters
                MarketMakerRewardRate: "0.002", // 0.2%
                StakingRewardRate:     "0.05",  // 5%
                LiquidityPoolFee:      "0.003", // 0.3%
                MaxSlippage:           "0.05",  // 5%
                MinLiquidityThreshold: 1000000, // 1 ANT in micro units
        }
}</span>

// Validate validates the parameters
func (p *Params) Validate() error <span class="cov8" title="1">{
        if p.MinAntAmount == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MinAntAmount cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MaxAntAmount == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxAntAmount cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.TradingFeeRate == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("TradingFeeRate cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MinOrderSize == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MinOrderSize cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MaxOrderSize == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxOrderSize cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.OrderExpiry &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("OrderExpiry must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.AntDenom == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("AntDenom cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MaxOpenOrders == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxOpenOrders must be greater than 0")
        }</span>
        <span class="cov8" title="1">if p.PricePrecision == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("PricePrecision cannot be empty")
        }</span>
        
        // Validate new economic parameters
        <span class="cov8" title="1">if p.MarketMakerRewardRate == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MarketMakerRewardRate cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.StakingRewardRate == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("StakingRewardRate cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.LiquidityPoolFee == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("LiquidityPoolFee cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MaxSlippage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxSlippage cannot be empty")
        }</span>
        <span class="cov8" title="1">if p.MinLiquidityThreshold == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MinLiquidityThreshold must be greater than 0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validation functions
func validateString(i interface{}) error <span class="cov8" title="1">{
        _, ok := i.(string)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected string, got %T", i)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateDuration(i interface{}) error <span class="cov8" title="1">{
        _, ok := i.(time.Duration)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected time.Duration, got %T", i)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateBool(i interface{}) error <span class="cov8" title="1">{
        _, ok := i.(bool)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected bool, got %T", i)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateUint32(i interface{}) error <span class="cov8" title="1">{
        u, ok := i.(uint32)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected uint32, got %T", i)
        }</span>
        <span class="cov8" title="1">if u == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("value must be greater than 0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateUint64(i interface{}) error <span class="cov0" title="0">{
        u, ok := i.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected uint64, got %T", i)
        }</span>
        <span class="cov0" title="0">if u == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("value must be greater than 0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package types

import (
        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
        "google.golang.org/protobuf/types/known/durationpb"
)

func (p Params) ToProto() *anteilv1.Params <span class="cov0" title="0">{
        return &amp;anteilv1.Params{
                MinAntAmount:                p.MinAntAmount,
                MaxAntAmount:                p.MaxAntAmount,
                TradingFeeRate:              p.TradingFeeRate,
                MinOrderSize:                p.MinOrderSize,
                MaxOrderSize:                p.MaxOrderSize,
                OrderExpiry:                 durationpb.New(p.OrderExpiry),
                RequireIdentityVerification: p.RequireIdentityVerification,
                AntDenom:                    p.AntDenom,
                MaxOpenOrders:               p.MaxOpenOrders,
                PricePrecision:              p.PricePrecision,
        }
}</span>

func ParamsFromProto(pp *anteilv1.Params) (Params, error) <span class="cov0" title="0">{
        if pp == nil </span><span class="cov0" title="0">{
                return DefaultParams(), nil
        }</span>
        <span class="cov0" title="0">return Params{
                MinAntAmount:                pp.MinAntAmount,
                MaxAntAmount:                pp.MaxAntAmount,
                TradingFeeRate:              pp.TradingFeeRate,
                MinOrderSize:                pp.MinOrderSize,
                MaxOrderSize:                pp.MaxOrderSize,
                OrderExpiry:                 pp.OrderExpiry.AsDuration(),
                RequireIdentityVerification: pp.RequireIdentityVerification,
                AntDenom:                    pp.AntDenom,
                MaxOpenOrders:               pp.MaxOpenOrders,
                PricePrecision:              pp.PricePrecision,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package types

import (
        "fmt"
        "strconv"
        "time"

        "cosmossdk.io/store/prefix"
        storetypes "cosmossdk.io/store/types"

        anteilv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/anteil/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// NewOrder creates a new Order instance
func NewOrder(owner string, orderType anteilv1.OrderType, orderSide anteilv1.OrderSide, antAmount string, price string, identityHash string) *anteilv1.Order <span class="cov8" title="1">{
        now := timestamppb.Now()
        expiresAt := timestamppb.New(now.AsTime().Add(24 * time.Hour)) // Default 24h expiry

        return &amp;anteilv1.Order{
                OrderId:      generateOrderID(owner, now.AsTime()),
                Owner:        owner,
                OrderType:    orderType,
                OrderSide:    orderSide,
                AntAmount:    antAmount,
                Price:        price,
                Status:       anteilv1.OrderStatus_ORDER_STATUS_OPEN,
                CreatedAt:    now,
                ExpiresAt:    expiresAt,
                IdentityHash: identityHash,
        }
}</span>

// NewTrade creates a new Trade instance
func NewTrade(buyOrderID string, sellOrderID string, buyer string, seller string, antAmount string, price string, identityHash string) *anteilv1.Trade <span class="cov8" title="1">{
        now := timestamppb.Now()

        return &amp;anteilv1.Trade{
                TradeId:      generateTradeID(buyOrderID, sellOrderID, now.AsTime()),
                BuyOrderId:   buyOrderID,
                SellOrderId:  sellOrderID,
                Buyer:        buyer,
                Seller:       seller,
                AntAmount:    antAmount,
                Price:        price,
                TotalValue:   calculateTotalValue(antAmount, price),
                ExecutedAt:   now,
                IdentityHash: identityHash,
        }
}</span>

// NewUserPosition creates a new UserPosition instance
func NewUserPosition(owner string, antBalance string) *anteilv1.UserPosition <span class="cov8" title="1">{
        now := timestamppb.Now()

        return &amp;anteilv1.UserPosition{
                Owner:        owner,
                AntBalance:   antBalance,
                LockedAnt:    "0",
                AvailableAnt: antBalance,
                OpenOrderIds: []string{},
                TotalTrades:  "0",
                TotalVolume:  "0",
                LastActivity: now,
        }
}</span>

// NewAuction creates a new Auction instance
func NewAuction(blockHeight uint64, antAmount string, reservePrice string) *anteilv1.Auction <span class="cov8" title="1">{
        now := timestamppb.Now()
        endTime := timestamppb.New(now.AsTime().Add(1 * time.Hour)) // Default 1h auction duration

        return &amp;anteilv1.Auction{
                AuctionId:    generateAuctionID(blockHeight, now.AsTime()),
                BlockHeight:  blockHeight,
                StartTime:    now,
                EndTime:      endTime,
                Status:       anteilv1.AuctionStatus_AUCTION_STATUS_OPEN,
                Bids:         []*anteilv1.Bid{},
                WinningBid:   "",
                ReservePrice: reservePrice,
                AntAmount:    antAmount,
        }
}</span>

// NewBid creates a new Bid instance
func NewBid(bidder string, auctionID string, amount string, identityHash string) *anteilv1.Bid <span class="cov8" title="1">{
        now := timestamppb.Now()

        return &amp;anteilv1.Bid{
                BidId:        generateBidID(bidder, auctionID, now.AsTime()),
                Bidder:       bidder,
                Amount:       amount,
                SubmittedAt:  now,
                IdentityHash: identityHash,
        }
}</span>

// IsOrderValid checks if the order is valid
func IsOrderValid(order *anteilv1.Order) error <span class="cov8" title="1">{
        if order.Owner == "" </span><span class="cov8" title="1">{
                return ErrEmptyOwner
        }</span>
        <span class="cov8" title="1">if order.AntAmount == "" </span><span class="cov0" title="0">{
                return ErrEmptyAntAmount
        }</span>
        <span class="cov8" title="1">if order.Price == "" </span><span class="cov0" title="0">{
                return ErrEmptyPrice
        }</span>
        <span class="cov8" title="1">if order.IdentityHash == "" </span><span class="cov0" title="0">{
                return ErrEmptyIdentityHash
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsTradeValid checks if the trade is valid
func IsTradeValid(trade *anteilv1.Trade) error <span class="cov8" title="1">{
        if trade.BuyOrderId == "" </span><span class="cov0" title="0">{
                return ErrEmptyBuyOrderID
        }</span>
        <span class="cov8" title="1">if trade.SellOrderId == "" </span><span class="cov0" title="0">{
                return ErrEmptySellOrderID
        }</span>
        <span class="cov8" title="1">if trade.Buyer == "" </span><span class="cov8" title="1">{
                return ErrEmptyBuyer
        }</span>
        <span class="cov8" title="1">if trade.Seller == "" </span><span class="cov0" title="0">{
                return ErrEmptySeller
        }</span>
        <span class="cov8" title="1">if trade.AntAmount == "" </span><span class="cov0" title="0">{
                return ErrEmptyAntAmount
        }</span>
        <span class="cov8" title="1">if trade.Price == "" </span><span class="cov0" title="0">{
                return ErrEmptyPrice
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsAuctionValid checks if the auction is valid
func IsAuctionValid(auction *anteilv1.Auction) error <span class="cov8" title="1">{
        if auction.AuctionId == "" </span><span class="cov0" title="0">{
                return ErrEmptyAuctionID
        }</span>
        <span class="cov8" title="1">if auction.ReservePrice == "" </span><span class="cov0" title="0">{
                return ErrEmptyReservePrice
        }</span>
        <span class="cov8" title="1">if auction.AntAmount == "" </span><span class="cov8" title="1">{
                return ErrEmptyAntAmount
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsBidValid checks if the bid is valid
func IsBidValid(bid *anteilv1.Bid) error <span class="cov8" title="1">{
        if bid.Bidder == "" </span><span class="cov8" title="1">{
                return ErrEmptyBidder
        }</span>
        <span class="cov8" title="1">if bid.Amount == "" </span><span class="cov0" title="0">{
                return ErrEmptyBidAmount
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsUserPositionValid checks if the user position is valid
func IsUserPositionValid(position *anteilv1.UserPosition) error <span class="cov8" title="1">{
        if position.Owner == "" </span><span class="cov8" title="1">{
                return ErrEmptyOwner
        }</span>
        <span class="cov8" title="1">if position.AntBalance == "" </span><span class="cov0" title="0">{
                return ErrEmptyAntBalance
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewOrderStore creates a new order store
func NewOrderStore(store storetypes.KVStore) storetypes.KVStore <span class="cov0" title="0">{
        return prefix.NewStore(store, OrderKeyPrefix)
}</span>

// NewTradeStore creates a new trade store
func NewTradeStore(store storetypes.KVStore) storetypes.KVStore <span class="cov0" title="0">{
        return prefix.NewStore(store, TradeKeyPrefix)
}</span>

// NewAuctionStore creates a new auction store
func NewAuctionStore(store storetypes.KVStore) storetypes.KVStore <span class="cov0" title="0">{
        return prefix.NewStore(store, AuctionKeyPrefix)
}</span>

// Helper functions

func generateOrderID(owner string, timestamp time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("order_%s_%d", owner, timestamp.Unix())
}</span>

func generateTradeID(buyOrderID, sellOrderID string, timestamp time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("trade_%s_%s_%d", buyOrderID, sellOrderID, timestamp.Unix())
}</span>

func generateAuctionID(blockHeight uint64, timestamp time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("auction_%d_%d", blockHeight, timestamp.Unix())
}</span>

func generateBidID(bidder, auctionID string, timestamp time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("bid_%s_%s_%d", bidder, auctionID, timestamp.Unix())
}</span>

func calculateTotalValue(antAmount, price string) string <span class="cov8" title="1">{
        // Simplified calculation - in real implementation this would use decimal arithmetic
        return fmt.Sprintf("%s", antAmount) // Placeholder
}</span>

// UpdateOrderStatus updates the status of an order
func UpdateOrderStatus(order *anteilv1.Order, status anteilv1.OrderStatus) <span class="cov8" title="1">{
        order.Status = status
}</span>

// UpdateUserPosition updates user position based on trade
func UpdateUserPosition(position *anteilv1.UserPosition, trade *anteilv1.Trade, isBuyer bool) <span class="cov8" title="1">{
        // Update trade count
        currentTrades, _ := strconv.ParseInt(position.TotalTrades, 10, 64)
        position.TotalTrades = fmt.Sprintf("%d", currentTrades+1)
        
        // Update volume
        currentVolume, _ := strconv.ParseInt(position.TotalVolume, 10, 64)
        tradeVolume, _ := strconv.ParseInt(trade.AntAmount, 10, 64)
        position.TotalVolume = fmt.Sprintf("%d", currentVolume+tradeVolume)
        
        // Update last activity
        position.LastActivity = timestamppb.Now()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package keeper

import (
        "fmt"
        "time"

        "cosmossdk.io/store/prefix"
        storetypes "cosmossdk.io/store/types"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
        "google.golang.org/protobuf/types/known/timestamppb"

        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
        "github.com/volnix-protocol/volnix-protocol/x/ident/types"
)

type (
        Keeper struct {
                cdc        codec.BinaryCodec
                storeKey   storetypes.StoreKey
                paramstore paramtypes.Subspace
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey storetypes.StoreKey,
        ps paramtypes.Subspace,
) *Keeper <span class="cov8" title="1">{
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() </span><span class="cov0" title="0">{
                ps = ps.WithKeyTable(types.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">return &amp;Keeper{
                cdc:        cdc,
                storeKey:   storeKey,
                paramstore: ps,
        }</span>
}

// GetParams returns the current parameters for the ident module
func (k Keeper) GetParams(ctx sdk.Context) types.Params <span class="cov8" title="1">{
        var params types.Params
        k.paramstore.GetParamSet(ctx, &amp;params)
        return params
}</span>

// SetParams sets the parameters for the ident module
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) <span class="cov8" title="1">{
        k.paramstore.SetParamSet(ctx, &amp;params)
}</span>

// SetVerifiedAccount stores a verified account in the store
func (k Keeper) SetVerifiedAccount(ctx sdk.Context, account *identv1.VerifiedAccount) error <span class="cov8" title="1">{
        if err := types.ValidateAccount(account); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        accountKey := types.GetVerifiedAccountKey(account.Address)

        // Check if account already exists
        if store.Has(accountKey) </span><span class="cov8" title="1">{
                return types.ErrAccountAlreadyExists
        }</span>

        // Check account limits
        <span class="cov8" title="1">params := k.GetParams(ctx)
        if err := k.checkAccountLimits(ctx, account.Role, params); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Store the account
        <span class="cov8" title="1">accountBz, err := k.cdc.Marshal(account)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal account: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(accountKey, accountBz)
        return nil</span>
}

// ========================================
// BLOCK PROCESSORS - BeginBlocker/EndBlocker Logic
// ========================================

// BeginBlocker processes events at the beginning of each block
func (k Keeper) BeginBlocker(ctx sdk.Context) error <span class="cov8" title="1">{
        // Check account activity and update roles if needed
        if err := k.checkAccountActivity(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check account activity: %w", err)
        }</span>

        // Process role migrations
        <span class="cov8" title="1">if err := k.processRoleMigrations(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process role migrations: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// EndBlocker processes events at the end of each block
func (k Keeper) EndBlocker(ctx sdk.Context) error <span class="cov0" title="0">{
        // Update account activity timestamps
        if err := k.updateAccountActivity(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update account activity: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkAccountActivity checks account activity and updates roles if needed
func (k Keeper) checkAccountActivity(ctx sdk.Context) error <span class="cov8" title="1">{
        allAccounts, err := k.GetAllVerifiedAccounts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get verified accounts: %w", err)
        }</span>

        <span class="cov8" title="1">currentTime := ctx.BlockTime()

        for _, account := range allAccounts </span><span class="cov8" title="1">{
                // Check if account has been inactive for too long
                lastActivity := account.GetLastActive().AsTime()

                var activityPeriod time.Duration
                switch account.GetRole() </span>{
                case identv1.Role_ROLE_CITIZEN:<span class="cov8" title="1">
                        activityPeriod = time.Duration(365 * 24 * time.Hour)</span> // 1 year
                case identv1.Role_ROLE_VALIDATOR:<span class="cov0" title="0">
                        activityPeriod = time.Duration(180 * 24 * time.Hour)</span> // 6 months
                default:<span class="cov0" title="0">
                        continue</span> // Skip guests
                }

                <span class="cov8" title="1">if currentTime.Sub(lastActivity) &gt; activityPeriod </span><span class="cov0" title="0">{
                        // Downgrade role to guest (ROLE_UNSPECIFIED = 0)
                        account.Role = identv1.Role_ROLE_UNSPECIFIED

                        // Update account in store
                        if err := k.UpdateVerifiedAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update inactive account: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// processRoleMigrations processes pending role migrations
func (k Keeper) processRoleMigrations(ctx sdk.Context) error <span class="cov8" title="1">{
        // This would process any pending role migrations
        // For now, it's a placeholder for future implementation
        return nil
}</span>

// updateAccountActivity updates activity timestamps for all accounts
func (k Keeper) updateAccountActivity(ctx sdk.Context) error <span class="cov0" title="0">{
        allAccounts, err := k.GetAllVerifiedAccounts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get verified accounts: %w", err)
        }</span>

        <span class="cov0" title="0">currentTime := ctx.BlockTime()

        for _, account := range allAccounts </span><span class="cov0" title="0">{
                // Update last activity timestamp
                account.LastActive = &amp;timestamppb.Timestamp{Seconds: currentTime.Unix()}

                // Update in store
                if err := k.UpdateVerifiedAccount(ctx, account); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update account activity: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetVerifiedAccount retrieves a verified account by address
func (k Keeper) GetVerifiedAccount(ctx sdk.Context, address string) (*identv1.VerifiedAccount, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        accountKey := types.GetVerifiedAccountKey(address)

        if !store.Has(accountKey) </span><span class="cov8" title="1">{
                return nil, types.ErrAccountNotFound
        }</span>

        <span class="cov8" title="1">accountBz := store.Get(accountKey)
        var account identv1.VerifiedAccount
        if err := k.cdc.Unmarshal(accountBz, &amp;account); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal account: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;account, nil</span>
}

// UpdateVerifiedAccount updates an existing verified account
func (k Keeper) UpdateVerifiedAccount(ctx sdk.Context, account *identv1.VerifiedAccount) error <span class="cov8" title="1">{
        if err := types.ValidateAccount(account); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        accountKey := types.GetVerifiedAccountKey(account.Address)

        // Check if account exists
        if !store.Has(accountKey) </span><span class="cov8" title="1">{
                return types.ErrAccountNotFound
        }</span>

        // Store the updated account
        <span class="cov8" title="1">accountBz, err := k.cdc.Marshal(account)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal account: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(accountKey, accountBz)
        return nil</span>
}

// DeleteVerifiedAccount removes a verified account from the store
func (k Keeper) DeleteVerifiedAccount(ctx sdk.Context, address string) error <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        accountKey := types.GetVerifiedAccountKey(address)

        if !store.Has(accountKey) </span><span class="cov8" title="1">{
                return types.ErrAccountNotFound
        }</span>

        <span class="cov8" title="1">store.Delete(accountKey)
        return nil</span>
}

// GetAllVerifiedAccounts retrieves all verified accounts
func (k Keeper) GetAllVerifiedAccounts(ctx sdk.Context) ([]*identv1.VerifiedAccount, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        accountStore := prefix.NewStore(store, types.VerifiedAccountKeyPrefix)

        var accounts []*identv1.VerifiedAccount
        iterator := accountStore.Iterator(nil, nil)
        defer func() </span><span class="cov8" title="1">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov8" title="1">for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                var account identv1.VerifiedAccount
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;account); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal account: %w", err)
                }</span>
                <span class="cov8" title="1">accounts = append(accounts, &amp;account)</span>
        }

        <span class="cov8" title="1">return accounts, nil</span>
}

// GetVerifiedAccountsByRole retrieves all verified accounts with a specific role
func (k Keeper) GetVerifiedAccountsByRole(ctx sdk.Context, role identv1.Role) ([]*identv1.VerifiedAccount, error) <span class="cov8" title="1">{
        allAccounts, err := k.GetAllVerifiedAccounts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var filteredAccounts []*identv1.VerifiedAccount
        for _, account := range allAccounts </span><span class="cov8" title="1">{
                if account.Role == role </span><span class="cov8" title="1">{
                        filteredAccounts = append(filteredAccounts, account)
                }</span>
        }

        <span class="cov8" title="1">return filteredAccounts, nil</span>
}

// checkAccountLimits verifies that account creation doesn't exceed limits
func (k Keeper) checkAccountLimits(ctx sdk.Context, role identv1.Role, params types.Params) error <span class="cov8" title="1">{
        var currentCount uint64
        var maxCount uint64

        switch role </span>{
        case identv1.Role_ROLE_CITIZEN:<span class="cov8" title="1">
                accounts, err := k.GetVerifiedAccountsByRole(ctx, identv1.Role_ROLE_CITIZEN)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">currentCount = uint64(len(accounts))
                maxCount = params.MaxIdentitiesPerAddress</span>

        case identv1.Role_ROLE_VALIDATOR:<span class="cov8" title="1">
                accounts, err := k.GetVerifiedAccountsByRole(ctx, identv1.Role_ROLE_VALIDATOR)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">currentCount = uint64(len(accounts))
                maxCount = params.MaxIdentitiesPerAddress</span>

        default:<span class="cov0" title="0">
                return types.ErrInvalidRole</span>
        }

        <span class="cov8" title="1">if currentCount &gt;= maxCount </span><span class="cov8" title="1">{
                return fmt.Errorf("account limit exceeded for role %s: current %d, max %d", role, currentCount, maxCount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateAccountActivity updates the last active timestamp for an account
func (k Keeper) UpdateAccountActivity(ctx sdk.Context, address string) error <span class="cov0" title="0">{
        account, err := k.GetVerifiedAccount(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">types.UpdateAccountActivity(account)
        return k.UpdateVerifiedAccount(ctx, account)</span>
}

// ChangeAccountRole changes the role of an existing account
func (k Keeper) ChangeAccountRole(ctx sdk.Context, address string, newRole identv1.Role) error <span class="cov8" title="1">{
        account, err := k.GetVerifiedAccount(ctx, address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if role change is allowed
        <span class="cov8" title="1">if err := k.validateRoleChange(ctx, account.Role, newRole); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check account limits for new role
        <span class="cov8" title="1">params := k.GetParams(ctx)
        if err := k.checkAccountLimits(ctx, newRole, params); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Change role and update activity
        <span class="cov8" title="1">types.ChangeAccountRole(account, newRole)
        return k.UpdateVerifiedAccount(ctx, account)</span>
}

// validateRoleChange checks if the role change is valid
func (k Keeper) validateRoleChange(ctx sdk.Context, oldRole, newRole identv1.Role) error <span class="cov8" title="1">{
        // Basic validation
        if newRole == identv1.Role_ROLE_UNSPECIFIED </span><span class="cov0" title="0">{
                return types.ErrInvalidRole
        }</span>

        // Allow same role (no change)
        <span class="cov8" title="1">if oldRole == newRole </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Add specific business rules for role changes here
        // For example, only allow certain role transitions

        <span class="cov8" title="1">return nil</span>
}

// SetRoleMigration sets a role migration request
func (k Keeper) SetRoleMigration(ctx sdk.Context, migration *identv1.RoleMigration) error <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        migrationKey := types.GetRoleMigrationKey(migration.FromAddress, migration.ToAddress)

        migrationBz, err := k.cdc.Marshal(migration)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">store.Set(migrationKey, migrationBz)

        return nil</span>
}

// GetRoleMigration retrieves a role migration by addresses
func (k Keeper) GetRoleMigration(ctx sdk.Context, fromAddress, toAddress string) (*identv1.RoleMigration, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        migrationKey := types.GetRoleMigrationKey(fromAddress, toAddress)

        if !store.Has(migrationKey) </span><span class="cov0" title="0">{
                return nil, types.ErrRoleMigrationNotFound
        }</span>

        <span class="cov0" title="0">migrationBz := store.Get(migrationKey)
        var migration identv1.RoleMigration
        if err := k.cdc.Unmarshal(migrationBz, &amp;migration); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;migration, nil</span>
}

// ExecuteRoleMigration executes a role migration
func (k Keeper) ExecuteRoleMigration(ctx sdk.Context, fromAddress, toAddress string) error <span class="cov0" title="0">{
        migration, err := k.GetRoleMigration(ctx, fromAddress, toAddress)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if migration is valid
        <span class="cov0" title="0">if migration.IsCompleted </span><span class="cov0" title="0">{
                return types.ErrInvalidMigrationStatus
        }</span>

        // Get source account
        <span class="cov0" title="0">sourceAccount, err := k.GetVerifiedAccount(ctx, fromAddress)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create target account with same role
        <span class="cov0" title="0">targetAccount := &amp;identv1.VerifiedAccount{
                Address:            toAddress,
                Role:               sourceAccount.Role,
                VerificationDate:   timestamppb.Now(),
                LastActive:         timestamppb.Now(),
                IsActive:           true,
                IdentityHash:       migration.MigrationHash,
                VerificationProvider: sourceAccount.VerificationProvider,
        }

        // Set target account
        if err := k.SetVerifiedAccount(ctx, targetAccount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deactivate source account
        <span class="cov0" title="0">sourceAccount.IsActive = false
        if err := k.UpdateVerifiedAccount(ctx, sourceAccount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update migration status
        <span class="cov0" title="0">migration.IsCompleted = true
        migration.MigrationDate = timestamppb.Now()
        return k.SetRoleMigration(ctx, migration)</span>
}

// GetAllRoleMigrations returns all role migrations
func (k Keeper) GetAllRoleMigrations(ctx sdk.Context) ([]*identv1.RoleMigration, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        prefix := types.RoleMigrationKeyPrefix

        var migrations []*identv1.RoleMigration
        iterator := store.Iterator(prefix, append(prefix, 0xFF))
        defer iterator.Close()

        for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var migration identv1.RoleMigration
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;migration); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">migrations = append(migrations, &amp;migration)</span>
        }

        <span class="cov0" title="0">return migrations, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package keeper

import (
        "context"
        "encoding/hex"

        sdk "github.com/cosmos/cosmos-sdk/types"
        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
        "github.com/volnix-protocol/volnix-protocol/x/ident/types"
        "golang.org/x/crypto/sha3"
)

type MsgServer struct {
        k Keeper
        identv1.UnimplementedMsgServer
}

func NewMsgServer(k *Keeper) MsgServer <span class="cov8" title="1">{ return MsgServer{k: *k} }</span>

var _ identv1.MsgServer = MsgServer{}

func (s MsgServer) VerifyIdentity(ctx context.Context, req *identv1.MsgVerifyIdentity) (*identv1.MsgVerifyIdentityResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // Validate request
        if req.Address == "" </span><span class="cov8" title="1">{
                return nil, types.ErrEmptyAddress
        }</span>
        <span class="cov8" title="1">if req.ZkpProof == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyIdentityHash
        }</span>
        <span class="cov8" title="1">if req.VerificationProvider == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAddress
        }</span>

        // Check if account already exists
        <span class="cov8" title="1">existingAccount, err := s.k.GetVerifiedAccount(sdkCtx, req.Address)
        if err == nil &amp;&amp; existingAccount != nil </span><span class="cov8" title="1">{
                return nil, types.ErrAccountAlreadyExists
        }</span>

        // Create new verified account (using ZKP proof hash as identity hash)
        <span class="cov8" title="1">hash := sha3.NewLegacyKeccak256()
        hash.Write([]byte(req.ZkpProof))
        identityHash := hex.EncodeToString(hash.Sum(nil))
        account := types.NewVerifiedAccount(req.Address, identv1.Role_ROLE_CITIZEN, identityHash)

        // Store the account
        if err := s.k.SetVerifiedAccount(sdkCtx, account); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Emit event
        <span class="cov8" title="1">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        "identity_verified",
                        sdk.NewAttribute("address", req.Address),
                        sdk.NewAttribute("verification_provider", req.VerificationProvider),
                        sdk.NewAttribute("identity_hash", identityHash),
                ),
        )

        return &amp;identv1.MsgVerifyIdentityResponse{
                Success:        true,
                VerificationId: "verification_" + req.Address,
                IdentityHash:   identityHash,
        }, nil</span>
}

func (s MsgServer) MigrateRole(ctx context.Context, req *identv1.MsgMigrateRole) (*identv1.MsgMigrateRoleResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // Validate request
        if req.ToAddress == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAddress
        }</span>
        <span class="cov8" title="1">if req.ZkpProof == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyIdentityHash
        }</span>

        // Get source account from request
        <span class="cov8" title="1">sender := req.FromAddress

        // Get source account
        sourceAccount, err := s.k.GetVerifiedAccount(sdkCtx, sender)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if target account already exists
        <span class="cov8" title="1">_, err = s.k.GetVerifiedAccount(sdkCtx, req.ToAddress)
        if err == nil </span><span class="cov0" title="0">{
                return nil, types.ErrAccountAlreadyExists
        }</span>

        // Create new account with migrated role and ZKP proof
        <span class="cov8" title="1">hash := sha3.NewLegacyKeccak256()
        hash.Write([]byte(req.ZkpProof))
        identityHash := string(hash.Sum(nil))
        newAccount := types.NewVerifiedAccount(req.ToAddress, sourceAccount.Role, identityHash)

        // Store the new account
        if err := s.k.SetVerifiedAccount(sdkCtx, newAccount); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Delete the old account
        <span class="cov0" title="0">if err := s.k.DeleteVerifiedAccount(sdkCtx, sender); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Emit event
        <span class="cov0" title="0">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        "role_migrated",
                        sdk.NewAttribute("from_address", sender),
                        sdk.NewAttribute("to_address", req.ToAddress),
                        sdk.NewAttribute("role", sourceAccount.Role.String()),
                ),
        )

        return &amp;identv1.MsgMigrateRoleResponse{Success: true}, nil</span>
}

func (s MsgServer) ChangeRole(ctx context.Context, req *identv1.MsgChangeRole) (*identv1.MsgChangeRoleResponse, error) <span class="cov8" title="1">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // Validate request
        if req.Address == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAddress
        }</span>
        <span class="cov8" title="1">if req.NewRole == identv1.Role_ROLE_UNSPECIFIED </span><span class="cov0" title="0">{
                return nil, types.ErrInvalidRole
        }</span>

        // Change the role
        <span class="cov8" title="1">if err := s.k.ChangeAccountRole(sdkCtx, req.Address, req.NewRole); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Emit event
        <span class="cov8" title="1">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        "role_changed",
                        sdk.NewAttribute("address", req.Address),
                        sdk.NewAttribute("new_role", req.NewRole.String()),
                ),
        )

        return &amp;identv1.MsgChangeRoleResponse{Success: true}, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkquery "github.com/cosmos/cosmos-sdk/types/query"
        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
        "github.com/volnix-protocol/volnix-protocol/x/ident/types"
        "google.golang.org/protobuf/encoding/protojson"
)

type QueryServer struct {
        k Keeper
        identv1.UnimplementedQueryServer
}

func NewQueryServer(k *Keeper) QueryServer <span class="cov0" title="0">{ return QueryServer{k: *k} }</span>

var _ identv1.QueryServer = QueryServer{}

func (s QueryServer) Params(ctx context.Context, _ *identv1.QueryParamsRequest) (*identv1.QueryParamsResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        params := s.k.GetParams(sdkCtx).ToProto()
        bz, err := protojson.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;identv1.QueryParamsResponse{Json: string(bz)}, nil</span>
}

func (s QueryServer) VerifiedAccount(ctx context.Context, req *identv1.QueryVerifiedAccountRequest) (*identv1.QueryVerifiedAccountResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        if req.Address == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAddress
        }</span>

        <span class="cov0" title="0">account, err := s.k.GetVerifiedAccount(sdkCtx, req.Address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;identv1.QueryVerifiedAccountResponse{Account: account}, nil</span>
}

func (s QueryServer) VerifiedAccounts(ctx context.Context, req *identv1.QueryVerifiedAccountsRequest) (*identv1.QueryVerifiedAccountsResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        accounts, err := s.k.GetAllVerifiedAccounts(sdkCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle pagination
        <span class="cov0" title="0">var pagination *sdkquery.PageResponse
        if req.Pagination != nil </span><span class="cov0" title="0">{
                // Simple pagination implementation
                offset := req.Pagination.Offset
                limit := req.Pagination.Limit

                if limit &gt; 0 &amp;&amp; offset &lt; uint64(len(accounts)) </span><span class="cov0" title="0">{
                        end := offset + limit
                        if end &gt; uint64(len(accounts)) </span><span class="cov0" title="0">{
                                end = uint64(len(accounts))
                        }</span>
                        <span class="cov0" title="0">accounts = accounts[offset:end]</span>
                }

                <span class="cov0" title="0">pagination = &amp;sdkquery.PageResponse{
                        NextKey: nil, // Simplified pagination
                }</span>
        }

        <span class="cov0" title="0">return &amp;identv1.QueryVerifiedAccountsResponse{
                Accounts:   accounts,
                Pagination: pagination,
        }, nil</span>
}

func (s QueryServer) VerifiedAccountsByRole(ctx context.Context, req *identv1.QueryVerifiedAccountsByRoleRequest) (*identv1.QueryVerifiedAccountsByRoleResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        if req.Role == identv1.Role_ROLE_UNSPECIFIED </span><span class="cov0" title="0">{
                return nil, types.ErrInvalidRole
        }</span>

        <span class="cov0" title="0">accounts, err := s.k.GetVerifiedAccountsByRole(sdkCtx, req.Role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle pagination
        <span class="cov0" title="0">var pagination *sdkquery.PageResponse
        if req.Pagination != nil </span><span class="cov0" title="0">{
                // Simple pagination implementation
                offset := req.Pagination.Offset
                limit := req.Pagination.Limit

                if limit &gt; 0 &amp;&amp; offset &lt; uint64(len(accounts)) </span><span class="cov0" title="0">{
                        end := offset + limit
                        if end &gt; uint64(len(accounts)) </span><span class="cov0" title="0">{
                                end = uint64(len(accounts))
                        }</span>
                        <span class="cov0" title="0">accounts = accounts[offset:end]</span>
                }

                <span class="cov0" title="0">pagination = &amp;sdkquery.PageResponse{
                        NextKey: nil, // Simplified pagination
                }</span>
        }

        <span class="cov0" title="0">return &amp;identv1.QueryVerifiedAccountsByRoleResponse{
                Accounts:   accounts,
                Pagination: pagination,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        "time"

        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// NewVerifiedAccount creates a new VerifiedAccount instance
func NewVerifiedAccount(address string, role identv1.Role, identityHash string) *identv1.VerifiedAccount <span class="cov0" title="0">{
        now := timestamppb.Now()
        return &amp;identv1.VerifiedAccount{
                Address:      address,
                Role:         role,
                LastActive:   now,
                IdentityHash: identityHash,
        }
}</span>

// IsAccountActive checks if the account is active based on inactivity period
func IsAccountActive(acc *identv1.VerifiedAccount, params Params) bool <span class="cov0" title="0">{
        lastActive := acc.LastActive.AsTime()
        now := time.Now()

        var inactivityPeriod time.Duration
        switch acc.Role </span>{
        case identv1.Role_ROLE_CITIZEN:<span class="cov0" title="0">
                inactivityPeriod = params.CitizenActivityPeriod</span>
        case identv1.Role_ROLE_VALIDATOR:<span class="cov0" title="0">
                inactivityPeriod = params.ValidatorActivityPeriod</span>
        default:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov0" title="0">return now.Sub(lastActive) &lt;= inactivityPeriod</span>
}

// UpdateAccountActivity updates the last active timestamp
func UpdateAccountActivity(acc *identv1.VerifiedAccount) <span class="cov0" title="0">{
        acc.LastActive = timestamppb.Now()
}</span>

// ChangeAccountRole changes the role of the account
func ChangeAccountRole(acc *identv1.VerifiedAccount, newRole identv1.Role) <span class="cov0" title="0">{
        acc.Role = newRole
        UpdateAccountActivity(acc)
}</span>

// ValidateAccount performs basic validation on the account
func ValidateAccount(acc *identv1.VerifiedAccount) error <span class="cov0" title="0">{
        if acc.Address == "" </span><span class="cov0" title="0">{
                return ErrEmptyAddress
        }</span>

        <span class="cov0" title="0">if acc.IdentityHash == "" </span><span class="cov0" title="0">{
                return ErrEmptyIdentityHash
        }</span>

        <span class="cov0" title="0">if acc.Role == identv1.Role_ROLE_UNSPECIFIED </span><span class="cov0" title="0">{
                return ErrInvalidRole
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package types

import (
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        txtypes "github.com/cosmos/cosmos-sdk/types/tx"

        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
)

// RegisterInterfaces registers module concrete types on the given InterfaceRegistry.
// Registers request and response messages for routing and amino/json compatibility.
func RegisterInterfaces(reg cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        // sdk.Msg requests
        reg.RegisterImplementations((*sdk.Msg)(nil),
                &amp;identv1.MsgVerifyIdentity{},
                &amp;identv1.MsgMigrateRole{},
                &amp;identv1.MsgChangeRole{},
                &amp;identv1.MsgRegisterVerificationProvider{},
        )

        // tx.MsgResponse responses
        reg.RegisterImplementations((*txtypes.MsgResponse)(nil),
                &amp;identv1.MsgVerifyIdentityResponse{},
                &amp;identv1.MsgMigrateRoleResponse{},
                &amp;identv1.MsgChangeRoleResponse{},
                &amp;identv1.MsgRegisterVerificationProviderResponse{},
        )
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

const (
        // ModuleName defines the module name
        ModuleName = "ident"

        // StoreKey is the KVStore key for the ident module
        StoreKey = ModuleName

        // RouterKey is the msg router key for the ident module (kept for compatibility)
        RouterKey = ModuleName

        // QuerierRoute is the querier route for the ident module
        QuerierRoute = ModuleName
)

var (
        // VerifiedAccountKeyPrefix defines the prefix for verified account keys
        VerifiedAccountKeyPrefix = []byte{0x01}

        // RoleMigrationKeyPrefix defines the prefix for role migration keys
        RoleMigrationKeyPrefix = []byte{0x02}
)

// GetVerifiedAccountKey returns the key for a verified account
func GetVerifiedAccountKey(address string) []byte <span class="cov0" title="0">{
        return append(VerifiedAccountKeyPrefix, []byte(address)...)
}</span>

// GetRoleMigrationKey returns the key for a role migration
func GetRoleMigrationKey(fromAddress, toAddress string) []byte <span class="cov0" title="0">{
        return append(RoleMigrationKeyPrefix, []byte(fromAddress+"_"+toAddress)...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package types

import (
        "fmt"
        "time"

        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkmath "cosmossdk.io/math"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

var (
        KeyCitizenActivityPeriod        = []byte("CitizenActivityPeriod")
        KeyValidatorActivityPeriod      = []byte("ValidatorActivityPeriod")
        KeyMaxIdentitiesPerAddress      = []byte("MaxIdentitiesPerAddress")
        KeyRequireIdentityVerification  = []byte("RequireIdentityVerification")
        KeyDefaultVerificationProvider  = []byte("DefaultVerificationProvider")
        KeyVerificationCost             = []byte("VerificationCost")
        KeyMigrationFee                 = []byte("MigrationFee")
        KeyRoleChangeFee                = []byte("RoleChangeFee")
)

// Ensure Params implements ParamSet
var _ paramtypes.ParamSet = (*Params)(nil)

// Params defines ident module parameters
type Params struct {
        CitizenActivityPeriod        time.Duration `json:"citizen_activity_period"`
        ValidatorActivityPeriod      time.Duration `json:"validator_activity_period"`
        MaxIdentitiesPerAddress      uint64        `json:"max_identities_per_address"`
        RequireIdentityVerification  bool          `json:"require_identity_verification"`
        DefaultVerificationProvider  string        `json:"default_verification_provider"`
        VerificationCost             sdk.Coin      `json:"verification_cost"`
        MigrationFee                 sdk.Coin      `json:"migration_fee"`
        RoleChangeFee                sdk.Coin      `json:"role_change_fee"`
}

// ParamKeyTable for ident module
func ParamKeyTable() paramtypes.KeyTable <span class="cov8" title="1">{
        return paramtypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

// ParamSetPairs returns the parameter set pairs
func (p *Params) ParamSetPairs() paramtypes.ParamSetPairs <span class="cov8" title="1">{
        return paramtypes.ParamSetPairs{
                paramtypes.NewParamSetPair(KeyCitizenActivityPeriod, &amp;p.CitizenActivityPeriod, validateDuration),
                paramtypes.NewParamSetPair(KeyValidatorActivityPeriod, &amp;p.ValidatorActivityPeriod, validateDuration),
                paramtypes.NewParamSetPair(KeyMaxIdentitiesPerAddress, &amp;p.MaxIdentitiesPerAddress, validateUint64),
                paramtypes.NewParamSetPair(KeyRequireIdentityVerification, &amp;p.RequireIdentityVerification, validateBool),
                paramtypes.NewParamSetPair(KeyDefaultVerificationProvider, &amp;p.DefaultVerificationProvider, validateString),
                paramtypes.NewParamSetPair(KeyVerificationCost, &amp;p.VerificationCost, validateCoin),
                paramtypes.NewParamSetPair(KeyMigrationFee, &amp;p.MigrationFee, validateCoin),
                paramtypes.NewParamSetPair(KeyRoleChangeFee, &amp;p.RoleChangeFee, validateCoin),
        }
}</span>

// DefaultParams returns default parameters
func DefaultParams() Params <span class="cov8" title="1">{
        return Params{
                CitizenActivityPeriod:        365 * 24 * time.Hour, // 1 year
                ValidatorActivityPeriod:      180 * 24 * time.Hour, // 6 months
                MaxIdentitiesPerAddress:      1,
                RequireIdentityVerification:  true,
                DefaultVerificationProvider:  "",
                VerificationCost:             sdk.NewCoin("uvx", sdkmath.NewInt(1000000)),
                MigrationFee:                 sdk.NewCoin("uvx", sdkmath.NewInt(500000)),
                RoleChangeFee:                sdk.NewCoin("uvx", sdkmath.NewInt(100000)),
        }
}</span>

// Validate performs basic validation of params
func (p Params) Validate() error <span class="cov8" title="1">{
        if err := validateDuration(p.CitizenActivityPeriod); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid CitizenActivityPeriod: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateDuration(p.ValidatorActivityPeriod); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ValidatorActivityPeriod: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateUint64(p.MaxIdentitiesPerAddress); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MaxIdentitiesPerAddress: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateBool(p.RequireIdentityVerification); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid RequireIdentityVerification: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateString(p.DefaultVerificationProvider); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DefaultVerificationProvider: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateCoin(p.VerificationCost); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid VerificationCost: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateCoin(p.MigrationFee); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid MigrationFee: %w", err)
        }</span>
        <span class="cov8" title="1">if err := validateCoin(p.RoleChangeFee); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid RoleChangeFee: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateDuration(i interface{}) error <span class="cov8" title="1">{
        d, ok := i.(time.Duration)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected time.Duration, got %T", i)
        }</span>
        <span class="cov8" title="1">if d &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("duration must be positive")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateUint64(i interface{}) error <span class="cov8" title="1">{
        u, ok := i.(uint64)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected uint64, got %T", i)
        }</span>
        <span class="cov8" title="1">if u == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("value must be greater than 0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateBool(i interface{}) error <span class="cov8" title="1">{
        _, ok := i.(bool)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected bool, got %T", i)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateString(i interface{}) error <span class="cov8" title="1">{
        _, ok := i.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected string, got %T", i)
        }</span>
        // Allow empty string for optional fields
        <span class="cov8" title="1">return nil</span>
}

func validateCoin(i interface{}) error <span class="cov8" title="1">{
        coin, ok := i.(sdk.Coin)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected sdk.Coin, got %T", i)
        }</span>
        <span class="cov8" title="1">if err := coin.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid coin: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import (
        identv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/ident/v1"
        "google.golang.org/protobuf/types/known/durationpb"
)

// ToProto converts local Params to protobuf Params
func (p Params) ToProto() *identv1.Params <span class="cov0" title="0">{
        return &amp;identv1.Params{
                CitizenActivityPeriod:        durationpb.New(p.CitizenActivityPeriod),
                ValidatorActivityPeriod:      durationpb.New(p.ValidatorActivityPeriod),
                MaxIdentitiesPerAddress:      p.MaxIdentitiesPerAddress,
                RequireIdentityVerification:  p.RequireIdentityVerification,
                DefaultVerificationProvider:  p.DefaultVerificationProvider,
                VerificationCost:             &amp;p.VerificationCost,
                MigrationFee:                 &amp;p.MigrationFee,
                RoleChangeFee:                &amp;p.RoleChangeFee,
        }
}</span>

// ParamsFromProto converts protobuf Params to local Params
func ParamsFromProto(pp *identv1.Params) Params <span class="cov0" title="0">{
        if pp == nil </span><span class="cov0" title="0">{
                return DefaultParams()
        }</span>
        <span class="cov0" title="0">return Params{
                CitizenActivityPeriod:        pp.CitizenActivityPeriod.AsDuration(),
                ValidatorActivityPeriod:      pp.ValidatorActivityPeriod.AsDuration(),
                MaxIdentitiesPerAddress:      pp.MaxIdentitiesPerAddress,
                RequireIdentityVerification:  pp.RequireIdentityVerification,
                DefaultVerificationProvider:  pp.DefaultVerificationProvider,
                VerificationCost:             *pp.VerificationCost,
                MigrationFee:                 *pp.MigrationFee,
                RoleChangeFee:                *pp.RoleChangeFee,
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package keeper

import (
        "fmt"
        "strconv"

        "cosmossdk.io/store/prefix"
        storetypes "cosmossdk.io/store/types"
        "github.com/cosmos/cosmos-sdk/codec"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"

        lizenzv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/lizenz/v1"
        "github.com/volnix-protocol/volnix-protocol/x/lizenz/types"
)

type (
        Keeper struct {
                cdc        codec.BinaryCodec
                storeKey   storetypes.StoreKey
                paramstore paramtypes.Subspace
        }
)

func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey storetypes.StoreKey,
        ps paramtypes.Subspace,
) *Keeper <span class="cov8" title="1">{
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() </span><span class="cov0" title="0">{
                ps = ps.WithKeyTable(types.ParamKeyTable())
        }</span>

        <span class="cov8" title="1">return &amp;Keeper{
                cdc:        cdc,
                storeKey:   storeKey,
                paramstore: ps,
        }</span>
}

// GetParams returns the current parameters for the lizenz module
func (k Keeper) GetParams(ctx sdk.Context) types.Params <span class="cov8" title="1">{
        var params types.Params
        k.paramstore.GetParamSet(ctx, &amp;params)
        return params
}</span>

// SetParams sets the parameters for the lizenz module
func (k Keeper) SetParams(ctx sdk.Context, params types.Params) <span class="cov8" title="1">{
        k.paramstore.SetParamSet(ctx, &amp;params)
}</span>

// SetActivatedLizenz stores an activated LZN license
func (k Keeper) SetActivatedLizenz(ctx sdk.Context, lizenz *lizenzv1.ActivatedLizenz) error <span class="cov8" title="1">{
        if err := types.IsActivatedLizenzValid(lizenz); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetActivatedLizenzKey(lizenz.Validator)

        // Check if LZN already exists
        if store.Has(lizenzKey) </span><span class="cov8" title="1">{
                return types.ErrLizenzAlreadyExists
        }</span>

        // Validate amount limits
        <span class="cov8" title="1">params := k.GetParams(ctx)
        if err := k.validateLizenzAmount(ctx, lizenz.Amount, params); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store the LZN
        <span class="cov8" title="1">lizenzBz, err := k.cdc.Marshal(lizenz)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal activated lizenz: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(lizenzKey, lizenzBz)
        return nil</span>
}

// GetActivatedLizenz retrieves an activated LZN license by validator address
func (k Keeper) GetActivatedLizenz(ctx sdk.Context, validator string) (*lizenzv1.ActivatedLizenz, error) <span class="cov8" title="1">{
        if validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetActivatedLizenzKey(validator)

        if !store.Has(lizenzKey) </span><span class="cov8" title="1">{
                return nil, types.ErrLizenzNotFound
        }</span>

        <span class="cov8" title="1">lizenzBz := store.Get(lizenzKey)
        var lizenz lizenzv1.ActivatedLizenz
        if err := k.cdc.Unmarshal(lizenzBz, &amp;lizenz); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal activated lizenz: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;lizenz, nil</span>
}

// UpdateActivatedLizenz updates an existing activated LZN license
func (k Keeper) UpdateActivatedLizenz(ctx sdk.Context, lizenz *lizenzv1.ActivatedLizenz) error <span class="cov8" title="1">{
        if err := types.IsActivatedLizenzValid(lizenz); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetActivatedLizenzKey(lizenz.Validator)

        // Check if LZN exists
        if !store.Has(lizenzKey) </span><span class="cov8" title="1">{
                return types.ErrLizenzNotFound
        }</span>

        // Store the updated LZN
        <span class="cov8" title="1">lizenzBz, err := k.cdc.Marshal(lizenz)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal activated lizenz: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(lizenzKey, lizenzBz)
        return nil</span>
}

// DeleteActivatedLizenz removes an activated LZN license
func (k Keeper) DeleteActivatedLizenz(ctx sdk.Context, validator string) error <span class="cov8" title="1">{
        if validator == "" </span><span class="cov0" title="0">{
                return types.ErrEmptyValidator
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetActivatedLizenzKey(validator)

        if !store.Has(lizenzKey) </span><span class="cov8" title="1">{
                return types.ErrLizenzNotFound
        }</span>

        <span class="cov8" title="1">store.Delete(lizenzKey)
        return nil</span>
}

// GetAllActivatedLizenz retrieves all activated LZN licenses
func (k Keeper) GetAllActivatedLizenz(ctx sdk.Context) ([]*lizenzv1.ActivatedLizenz, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        lizenzStore := prefix.NewStore(store, types.ActivatedLizenzKeyPrefix)

        var lizenzs []*lizenzv1.ActivatedLizenz
        iterator := lizenzStore.Iterator(nil, nil)
        defer func() </span><span class="cov8" title="1">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov8" title="1">for ; iterator.Valid(); iterator.Next() </span><span class="cov8" title="1">{
                var lizenz lizenzv1.ActivatedLizenz
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;lizenz); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal activated lizenz: %w", err)
                }</span>
                <span class="cov8" title="1">lizenzs = append(lizenzs, &amp;lizenz)</span>
        }

        <span class="cov8" title="1">return lizenzs, nil</span>
}

// SetLizenz is an alias for SetActivatedLizenz for backward compatibility
func (k Keeper) SetLizenz(ctx sdk.Context, lizenz *lizenzv1.ActivatedLizenz) error <span class="cov8" title="1">{
        return k.SetActivatedLizenz(ctx, lizenz)
}</span>

// GetLizenz is an alias for GetActivatedLizenz for backward compatibility
func (k Keeper) GetLizenz(ctx sdk.Context, validator string) (*lizenzv1.ActivatedLizenz, error) <span class="cov8" title="1">{
        return k.GetActivatedLizenz(ctx, validator)
}</span>

// UpdateLizenz is an alias for UpdateActivatedLizenz for backward compatibility
func (k Keeper) UpdateLizenz(ctx sdk.Context, lizenz *lizenzv1.ActivatedLizenz) error <span class="cov8" title="1">{
        return k.UpdateActivatedLizenz(ctx, lizenz)
}</span>

// DeleteLizenz is an alias for DeleteActivatedLizenz for backward compatibility
func (k Keeper) DeleteLizenz(ctx sdk.Context, validator string) error <span class="cov8" title="1">{
        return k.DeleteActivatedLizenz(ctx, validator)
}</span>

// GetAllLizenzs is an alias for GetAllActivatedLizenz for backward compatibility
func (k Keeper) GetAllLizenzs(ctx sdk.Context) ([]*lizenzv1.ActivatedLizenz, error) <span class="cov8" title="1">{
        return k.GetAllActivatedLizenz(ctx)
}</span>

// ActivateLizenz activates a LZN license
func (k Keeper) ActivateLizenz(ctx sdk.Context, validator string) error <span class="cov8" title="1">{
        lizenz, err := k.GetActivatedLizenz(ctx, validator)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update status to active
        <span class="cov8" title="1">lizenz.IsEligibleForRewards = true
        return k.UpdateActivatedLizenz(ctx, lizenz)</span>
}

// DeactivateLizenz deactivates a LZN license
func (k Keeper) DeactivateLizenz(ctx sdk.Context, validator string) error <span class="cov8" title="1">{
        lizenz, err := k.GetActivatedLizenz(ctx, validator)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update status to inactive
        <span class="cov8" title="1">lizenz.IsEligibleForRewards = false
        return k.UpdateActivatedLizenz(ctx, lizenz)</span>
}

// TransferLizenz transfers a LZN license to another validator
func (k Keeper) TransferLizenz(ctx sdk.Context, fromValidator, toValidator string) error <span class="cov8" title="1">{
        lizenz, err := k.GetActivatedLizenz(ctx, fromValidator)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Delete the old lizenz
        <span class="cov8" title="1">if err := k.DeleteActivatedLizenz(ctx, fromValidator); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update owner and create new lizenz
        <span class="cov8" title="1">lizenz.Validator = toValidator
        return k.SetActivatedLizenz(ctx, lizenz)</span>
}

// CheckMOA checks MOA compliance for a validator
func (k Keeper) CheckMOA(ctx sdk.Context, validator string) (bool, error) <span class="cov8" title="1">{
        status, err := k.GetMOAStatus(ctx, validator)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Parse MOA values for comparison
        <span class="cov8" title="1">currentMoa, err := strconv.ParseInt(status.CurrentMoa, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid current MOA: %w", err)
        }</span>

        <span class="cov8" title="1">requiredMoa, err := strconv.ParseInt(status.RequiredMoa, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid required MOA: %w", err)
        }</span>

        <span class="cov8" title="1">return currentMoa &gt;= requiredMoa, nil</span>
}

// BeginBlocker processes MOA violations and inactive LZN licenses
func (k Keeper) BeginBlocker(ctx sdk.Context) error <span class="cov8" title="1">{
        // Check for inactive LZN licenses
        if err := k.CheckInactiveLizenz(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Process deactivating LZN licenses
        <span class="cov8" title="1">if err := k.ProcessDeactivatingLizenz(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SetDeactivatingLizenz stores a deactivating LZN license
func (k Keeper) SetDeactivatingLizenz(ctx sdk.Context, lizenz *lizenzv1.DeactivatingLizenz) error <span class="cov0" title="0">{
        if err := types.IsDeactivatingLizenzValid(lizenz); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetDeactivatingLizenzKey(lizenz.Validator)

        // Check if deactivating LZN already exists
        if store.Has(lizenzKey) </span><span class="cov0" title="0">{
                return types.ErrLizenzAlreadyExists
        }</span>

        // Store the deactivating LZN
        <span class="cov0" title="0">lizenzBz, err := k.cdc.Marshal(lizenz)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal deactivating lizenz: %w", err)
        }</span>

        <span class="cov0" title="0">store.Set(lizenzKey, lizenzBz)
        return nil</span>
}

// GetDeactivatingLizenz retrieves a deactivating LZN license
func (k Keeper) GetDeactivatingLizenz(ctx sdk.Context, validator string) (*lizenzv1.DeactivatingLizenz, error) <span class="cov0" title="0">{
        if validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetDeactivatingLizenzKey(validator)

        if !store.Has(lizenzKey) </span><span class="cov0" title="0">{
                return nil, types.ErrLizenzNotFound
        }</span>

        <span class="cov0" title="0">lizenzBz := store.Get(lizenzKey)
        var lizenz lizenzv1.DeactivatingLizenz
        if err := k.cdc.Unmarshal(lizenzBz, &amp;lizenz); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal deactivating lizenz: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;lizenz, nil</span>
}

// GetAllDeactivatingLizenz retrieves all deactivating LZN licenses
func (k Keeper) GetAllDeactivatingLizenz(ctx sdk.Context) ([]*lizenzv1.DeactivatingLizenz, error) <span class="cov8" title="1">{
        store := ctx.KVStore(k.storeKey)
        lizenzStore := prefix.NewStore(store, types.DeactivatingLizenzKeyPrefix)

        var lizenzs []*lizenzv1.DeactivatingLizenz
        iterator := lizenzStore.Iterator(nil, nil)
        defer func() </span><span class="cov8" title="1">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov8" title="1">for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var lizenz lizenzv1.DeactivatingLizenz
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;lizenz); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal deactivating lizenz: %w", err)
                }</span>
                <span class="cov0" title="0">lizenzs = append(lizenzs, &amp;lizenz)</span>
        }

        <span class="cov8" title="1">return lizenzs, nil</span>
}

// DeleteDeactivatingLizenz removes a deactivating LZN license
func (k Keeper) DeleteDeactivatingLizenz(ctx sdk.Context, validator string) error <span class="cov0" title="0">{
        if validator == "" </span><span class="cov0" title="0">{
                return types.ErrEmptyValidator
        }</span>

        <span class="cov0" title="0">store := ctx.KVStore(k.storeKey)
        lizenzKey := types.GetDeactivatingLizenzKey(validator)

        if !store.Has(lizenzKey) </span><span class="cov0" title="0">{
                return types.ErrLizenzNotFound
        }</span>

        <span class="cov0" title="0">store.Delete(lizenzKey)
        return nil</span>
}

// SetMOAStatus stores MOA status for a validator
func (k Keeper) SetMOAStatus(ctx sdk.Context, status *lizenzv1.MOAStatus) error <span class="cov8" title="1">{
        if err := types.IsMOAStatusValid(status); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        statusKey := types.GetMOAStatusKey(status.Validator)

        // Store the MOA status
        statusBz, err := k.cdc.Marshal(status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal MOA status: %w", err)
        }</span>

        <span class="cov8" title="1">store.Set(statusKey, statusBz)
        return nil</span>
}

// GetMOAStatus retrieves MOA status for a validator
func (k Keeper) GetMOAStatus(ctx sdk.Context, validator string) (*lizenzv1.MOAStatus, error) <span class="cov8" title="1">{
        if validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>

        <span class="cov8" title="1">store := ctx.KVStore(k.storeKey)
        statusKey := types.GetMOAStatusKey(validator)

        if !store.Has(statusKey) </span><span class="cov8" title="1">{
                return nil, types.ErrLizenzNotFound
        }</span>

        <span class="cov8" title="1">statusBz := store.Get(statusKey)
        var status lizenzv1.MOAStatus
        if err := k.cdc.Unmarshal(statusBz, &amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal MOA status: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}

// GetAllMOAStatus retrieves all MOA statuses
func (k Keeper) GetAllMOAStatus(ctx sdk.Context) ([]*lizenzv1.MOAStatus, error) <span class="cov0" title="0">{
        store := ctx.KVStore(k.storeKey)
        statusStore := prefix.NewStore(store, types.MOAStatusKeyPrefix)

        var statuses []*lizenzv1.MOAStatus
        iterator := statusStore.Iterator(nil, nil)
        defer func() </span><span class="cov0" title="0">{
                if err := iterator.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to close iterator: %v", err))</span>
                }
        }()

        <span class="cov0" title="0">for ; iterator.Valid(); iterator.Next() </span><span class="cov0" title="0">{
                var status lizenzv1.MOAStatus
                if err := k.cdc.Unmarshal(iterator.Value(), &amp;status); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal MOA status: %w", err)
                }</span>
                <span class="cov0" title="0">statuses = append(statuses, &amp;status)</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}

// UpdateLizenzActivity updates the last activity timestamp for a validator
func (k Keeper) UpdateLizenzActivity(ctx sdk.Context, validator string) error <span class="cov0" title="0">{
        // Update activated LZN activity
        if activatedLizenz, err := k.GetActivatedLizenz(ctx, validator); err == nil </span><span class="cov0" title="0">{
                types.UpdateActivatedLizenzActivity(activatedLizenz)
                if err := k.UpdateActivatedLizenz(ctx, activatedLizenz); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Update MOA status activity
        <span class="cov0" title="0">if moaStatus, err := k.GetMOAStatus(ctx, validator); err == nil </span><span class="cov0" title="0">{
                // Calculate new MOA based on activity
                params := k.GetParams(ctx)
                newMOA, err := types.CalculateMOA("activity_data", params)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">types.UpdateMOAStatusActivity(moaStatus, newMOA)
                if err := k.SetMOAStatus(ctx, moaStatus); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateLizenzAmount validates LZN amount against module parameters
func (k Keeper) validateLizenzAmount(ctx sdk.Context, amount string, params types.Params) error <span class="cov8" title="1">{
        if amount == "" </span><span class="cov0" title="0">{
                return types.ErrEmptyAmount
        }</span>

        // Parse amount as integers for proper comparison
        <span class="cov8" title="1">amountInt, err := strconv.ParseInt(amount, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return types.ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">minAmount, err := strconv.ParseInt(params.MinLznAmount, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return types.ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">maxAmount, err := strconv.ParseInt(params.MaxLznAmount, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return types.ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">if amountInt &lt; minAmount </span><span class="cov0" title="0">{
                return types.ErrBelowMinAmount
        }</span>
        <span class="cov8" title="1">if amountInt &gt; maxAmount </span><span class="cov0" title="0">{
                return types.ErrExceedsMaxActivated
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CheckInactiveLizenz checks for inactive LZN licenses and moves them to deactivating state
func (k Keeper) CheckInactiveLizenz(ctx sdk.Context) error <span class="cov8" title="1">{
        params := k.GetParams(ctx)
        inactivityThreshold := ctx.BlockTime().Add(-params.InactivityPeriod)

        activatedLizenzs, err := k.GetAllActivatedLizenz(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, lizenz := range activatedLizenzs </span><span class="cov8" title="1">{
                if lizenz.LastActivity.AsTime().Before(inactivityThreshold) </span><span class="cov0" title="0">{
                        // Move to deactivating state
                        deactivatingLizenz := types.NewDeactivatingLizenz(
                                lizenz.Validator,
                                lizenz.Amount,
                                "inactivity",
                        )

                        if err := k.SetDeactivatingLizenz(ctx, deactivatingLizenz); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if err := k.DeleteActivatedLizenz(ctx, lizenz.Validator); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ProcessDeactivatingLizenz processes deactivating LZN licenses that have completed their period
func (k Keeper) ProcessDeactivatingLizenz(ctx sdk.Context) error <span class="cov8" title="1">{
        params := k.GetParams(ctx)
        deactivationThreshold := ctx.BlockTime().Add(-params.DeactivationPeriod)

        deactivatingLizenzs, err := k.GetAllDeactivatingLizenz(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, lizenz := range deactivatingLizenzs </span><span class="cov0" title="0">{
                if lizenz.DeactivationEnd.AsTime().Before(deactivationThreshold) </span><span class="cov0" title="0">{
                        // Deactivation period completed, remove the LZN
                        if err := k.DeleteDeactivatingLizenz(ctx, lizenz.Validator); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package keeper

import (
        "context"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        lizenzv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/lizenz/v1"
        "github.com/volnix-protocol/volnix-protocol/x/lizenz/types"
)

type MsgServer struct {
        k *Keeper
        lizenzv1.UnimplementedMsgServer
}

func NewMsgServer(k *Keeper) MsgServer <span class="cov0" title="0">{ return MsgServer{k: k} }</span>

var _ lizenzv1.MsgServer = MsgServer{}

func (s MsgServer) ActivateLZN(ctx context.Context, req *lizenzv1.MsgActivateLZN) (*lizenzv1.MsgActivateLZNResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // Validate request
        if req.Validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>
        <span class="cov0" title="0">if req.Amount == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAmount
        }</span>
        <span class="cov0" title="0">if req.IdentityHash == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyIdentityHash
        }</span>

        // Check if LZN already exists
        <span class="cov0" title="0">existingLizenz, err := s.k.GetActivatedLizenz(sdkCtx, req.Validator)
        if err == nil &amp;&amp; existingLizenz != nil </span><span class="cov0" title="0">{
                return nil, types.ErrLizenzAlreadyExists
        }</span>

        // Create new activated LZN
        <span class="cov0" title="0">lizenz := types.NewActivatedLizenz(req.Validator, req.Amount, req.IdentityHash)

        // Store the LZN
        if err := s.k.SetActivatedLizenz(sdkCtx, lizenz); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create initial MOA status
        <span class="cov0" title="0">moaStatus := types.NewMOAStatus(req.Validator, "100.0", "50.0") // Default values
        if err := s.k.SetMOAStatus(sdkCtx, moaStatus); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Emit event
        <span class="cov0" title="0">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        "lizenz_activated",
                        sdk.NewAttribute("validator", req.Validator),
                        sdk.NewAttribute("amount", req.Amount),
                        sdk.NewAttribute("identity_hash", req.IdentityHash),
                ),
        )

        return &amp;lizenzv1.MsgActivateLZNResponse{
                Success:      true,
                ActivationId: fmt.Sprintf("lzn_%s_%d", req.Validator, sdkCtx.BlockHeight()),
        }, nil</span>
}

func (s MsgServer) DeactivateLZN(ctx context.Context, req *lizenzv1.MsgDeactivateLZN) (*lizenzv1.MsgDeactivateLZNResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        // Validate request
        if req.Validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>
        <span class="cov0" title="0">if req.Amount == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyAmount
        }</span>
        <span class="cov0" title="0">if req.Reason == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyReason
        }</span>

        // Check if activated LZN exists
        <span class="cov0" title="0">if _, err := s.k.GetActivatedLizenz(sdkCtx, req.Validator); err != nil </span><span class="cov0" title="0">{
                return nil, types.ErrLizenzNotFound
        }</span>

        // Create deactivating LZN
        <span class="cov0" title="0">deactivatingLizenz := types.NewDeactivatingLizenz(req.Validator, req.Amount, req.Reason)

        // Store the deactivating LZN
        if err := s.k.SetDeactivatingLizenz(sdkCtx, deactivatingLizenz); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Remove the activated LZN
        <span class="cov0" title="0">if err := s.k.DeleteActivatedLizenz(sdkCtx, req.Validator); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Emit event
        <span class="cov0" title="0">sdkCtx.EventManager().EmitEvent(
                sdk.NewEvent(
                        "lizenz_deactivated",
                        sdk.NewAttribute("validator", req.Validator),
                        sdk.NewAttribute("amount", req.Amount),
                        sdk.NewAttribute("reason", req.Reason),
                ),
        )

        return &amp;lizenzv1.MsgDeactivateLZNResponse{
                Success:        true,
                DeactivationId: fmt.Sprintf("lzn_deact_%s_%d", req.Validator, sdkCtx.BlockHeight()),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package keeper

import (
        "context"

        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkquery "github.com/cosmos/cosmos-sdk/types/query"
        lizenzv1 "github.com/volnix-protocol/volnix-protocol/proto/gen/go/volnix/lizenz/v1"
        "github.com/volnix-protocol/volnix-protocol/x/lizenz/types"
        "google.golang.org/protobuf/encoding/protojson"
)

type QueryServer struct {
        k *Keeper
        lizenzv1.UnimplementedQueryServer
}

func NewQueryServer(k *Keeper) QueryServer <span class="cov0" title="0">{ return QueryServer{k: k} }</span>

var _ lizenzv1.QueryServer = QueryServer{}

func (s QueryServer) Params(ctx context.Context, _ *lizenzv1.QueryParamsRequest) (*lizenzv1.QueryParamsResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)
        params := s.k.GetParams(sdkCtx).ToProto()
        bz, err := protojson.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;lizenzv1.QueryParamsResponse{Json: string(bz)}, nil</span>
}

func (s QueryServer) Activated(ctx context.Context, req *lizenzv1.QueryActivatedRequest) (*lizenzv1.QueryActivatedResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        activatedLizenzs, err := s.k.GetAllActivatedLizenz(sdkCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle pagination
        <span class="cov0" title="0">var pagination *sdkquery.PageResponse
        if req.Pagination != nil </span><span class="cov0" title="0">{
                offset := req.Pagination.Offset
                limit := req.Pagination.Limit

                if limit &gt; 0 &amp;&amp; offset &lt; uint64(len(activatedLizenzs)) </span><span class="cov0" title="0">{
                        end := offset + limit
                        if end &gt; uint64(len(activatedLizenzs)) </span><span class="cov0" title="0">{
                                end = uint64(len(activatedLizenzs))
                        }</span>
                        <span class="cov0" title="0">activatedLizenzs = activatedLizenzs[offset:end]</span>
                }

                <span class="cov0" title="0">pagination = &amp;sdkquery.PageResponse{
                        NextKey: nil, // Simplified pagination
                }</span>
        }

        <span class="cov0" title="0">return &amp;lizenzv1.QueryActivatedResponse{
                Items:      activatedLizenzs,
                Pagination: pagination,
        }, nil</span>
}

func (s QueryServer) MOA(ctx context.Context, req *lizenzv1.QueryMOARequest) (*lizenzv1.QueryMOAResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        if req.Validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>

        <span class="cov0" title="0">moaStatus, err := s.k.GetMOAStatus(sdkCtx, req.Validator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;lizenzv1.QueryMOAResponse{Status: moaStatus}, nil</span>
}

func (s QueryServer) Deactivating(ctx context.Context, req *lizenzv1.QueryDeactivatingRequest) (*lizenzv1.QueryDeactivatingResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        deactivatingLizenzs, err := s.k.GetAllDeactivatingLizenz(sdkCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle pagination
        <span class="cov0" title="0">var pagination *sdkquery.PageResponse
        if req.Pagination != nil </span><span class="cov0" title="0">{
                offset := req.Pagination.Offset
                limit := req.Pagination.Limit

                if limit &gt; 0 &amp;&amp; offset &lt; uint64(len(deactivatingLizenzs)) </span><span class="cov0" title="0">{
                        end := offset + limit
                        if end &gt; uint64(len(deactivatingLizenzs)) </span><span class="cov0" title="0">{
                                end = uint64(len(deactivatingLizenzs))
                        }</span>
                        <span class="cov0" title="0">deactivatingLizenzs = deactivatingLizenzs[offset:end]</span>
                }

                <span class="cov0" title="0">pagination = &amp;sdkquery.PageResponse{
                        NextKey: nil, // Simplified pagination
                }</span>
        }

        <span class="cov0" title="0">return &amp;lizenzv1.QueryDeactivatingResponse{
                Items:      deactivatingLizenzs,
                Pagination: pagination,
        }, nil</span>
}

func (s QueryServer) ValidatorLZN(ctx context.Context, req *lizenzv1.QueryValidatorLZNRequest) (*lizenzv1.QueryValidatorLZNResponse, error) <span class="cov0" title="0">{
        sdkCtx := sdk.UnwrapSDKContext(ctx)

        if req.Validator == "" </span><span class="cov0" title="0">{
                return nil, types.ErrEmptyValidator
        }</span>

        <span class="cov0" title="0">activatedLizenz, _ := s.k.GetActivatedLizenz(sdkCtx, req.Validator)
        deactivatingLizenzs, _ := s.k.GetAllDeactivatingLizenz(sdkCtx)
        moaStatus, _ := s.k.GetMOAStatus(sdkCtx, req.Validator)

        // Filter deactivating LZN for this validator
        var validatorDeactivating []*lizenzv1.DeactivatingLizenz
        for _, dl := range deactivatingLizenzs </span><span class="cov0" title="0">{
                if dl.Validator == req.Validator </span><span class="cov0" title="0">{
                        validatorDeactivating = append(validatorDeactivating, dl)
                }</span>
        }

        <span class="cov0" title="0">return &amp;lizenzv1.QueryValidatorLZNResponse{
                Activated:    activatedLizenz,
                Deactivating: validatorDeactivating,
                MoaStatus:    moaStatus,
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
